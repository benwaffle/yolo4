{
    "auth": {
        "oauth2": {
            "scopes": {
                "https://www.googleapis.com/auth/plx": {
                    "description": "View and manage your Plx resources"
                }
            }
        }
    },
    "basePath": "",
    "baseUrl": "https://staging-dreampipe-pa.sandbox.googleapis.com/",
    "batchPath": "batch",
    "description": "",
    "discoveryVersion": "v1",
    "documentationLink": "",
    "icons": {
        "x16": "http://www.google.com/images/icons/product/search-16.gif",
        "x32": "http://www.google.com/images/icons/product/search-32.gif"
    },
    "id": "dreampipe_pa:v1",
    "kind": "discovery#restDescription",
    "name": "dreampipe_pa",
    "ownerDomain": "google.com",
    "ownerName": "Google",
    "parameters": {
        "$.xgafv": {
            "description": "V1 error format.",
            "enum": [
                "1",
                "2"
            ],
            "enumDescriptions": [
                "v1 error format",
                "v2 error format"
            ],
            "location": "query",
            "type": "string"
        },
        "access_token": {
            "description": "OAuth access token.",
            "location": "query",
            "type": "string"
        },
        "alt": {
            "default": "json",
            "description": "Data format for response.",
            "enum": [
                "json",
                "media",
                "proto"
            ],
            "enumDescriptions": [
                "Responses with Content-Type of application/json",
                "Media download with context-dependent Content-Type",
                "Responses with Content-Type of application/x-protobuf"
            ],
            "location": "query",
            "type": "string"
        },
        "callback": {
            "description": "JSONP",
            "location": "query",
            "type": "string"
        },
        "fields": {
            "description": "Selector specifying which fields to include in a partial response.",
            "location": "query",
            "type": "string"
        },
        "key": {
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.",
            "location": "query",
            "type": "string"
        },
        "oauth_token": {
            "description": "OAuth 2.0 token for the current user.",
            "location": "query",
            "type": "string"
        },
        "prettyPrint": {
            "default": "true",
            "description": "Returns response with indentations and line breaks.",
            "location": "query",
            "type": "boolean"
        },
        "quotaUser": {
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.",
            "location": "query",
            "type": "string"
        },
        "uploadType": {
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\").",
            "location": "query",
            "type": "string"
        },
        "upload_protocol": {
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\").",
            "location": "query",
            "type": "string"
        }
    },
    "protocol": "rest",
    "resources": {
        "domain": {
            "methods": {
                "createBackfill_new": {
                    "description": "Create a new version of a backfill. If the backfill does not exist, a new\nbackfill is created. The new version takes effect immediately.",
                    "flatPath": "v1/domain/{domainId}/backfill_new",
                    "httpMethod": "PUT",
                    "id": "dreampipe_pa.domain.createBackfill_new",
                    "parameterOrder": [
                        "domain"
                    ],
                    "parameters": {
                        "domain": {
                            "description": "The domain of the backfill, needs to be specified.",
                            "location": "path",
                            "pattern": "^[^/]+$",
                            "required": true,
                            "type": "string"
                        }
                    },
                    "path": "v1/domain/{+domain}/backfill_new",
                    "request": {
                        "$ref": "DreampipeServer..CreateBackfillVersionRequest"
                    },
                    "response": {
                        "$ref": "DreampipeServer..CreateBackfillVersionResponse"
                    },
                    "scopes": [
                        "https://www.googleapis.com/auth/plx"
                    ]
                },
                "get": {
                    "description": "GetDomainInfo retrieves info for one fully specified domain. This API reads\nSpanner directly so it always returns the latest state (e.g. if an output\nwas deleted prior to invoking this API this will be immediately reflected).\nThis user calling this API needs to have DOMAIN_READER or DOMAIN_WRITER\npermission.",
                    "flatPath": "v1/domain/{domainId}",
                    "httpMethod": "GET",
                    "id": "dreampipe_pa.domain.get",
                    "parameterOrder": [
                        "domain"
                    ],
                    "parameters": {
                        "domain": {
                            "location": "path",
                            "pattern": "^[^/]+$",
                            "required": true,
                            "type": "string"
                        }
                    },
                    "path": "v1/domain/{+domain}",
                    "response": {
                        "$ref": "DomainInfo"
                    },
                    "scopes": [
                        "https://www.googleapis.com/auth/plx"
                    ]
                },
                "outputs_graph": {
                    "description": "Returns the graph of outputs in the specified domain.",
                    "flatPath": "v1/domain/{domainId}/outputs_graph",
                    "httpMethod": "GET",
                    "id": "dreampipe_pa.domain.outputs_graph",
                    "parameterOrder": [
                        "domain"
                    ],
                    "parameters": {
                        "domain": {
                            "location": "path",
                            "pattern": "^[^/]+$",
                            "required": true,
                            "type": "string"
                        },
                        "mandateId": {
                            "description": "Id of the mandate which should be used to construct the outputs graph. If\nnot specified, the graph is constructed per default mandate.",
                            "location": "query",
                            "type": "string"
                        }
                    },
                    "path": "v1/domain/{+domain}/outputs_graph",
                    "response": {
                        "$ref": "OutputsGraphResponse"
                    },
                    "scopes": [
                        "https://www.googleapis.com/auth/plx"
                    ]
                }
            },
            "resources": {
                "backfill": {
                    "methods": {
                        "approval": {
                            "description": "Approves the backfill identified by the ApproveBackfillRequest.",
                            "flatPath": "v1/domain/{domainId}/backfill/approval",
                            "httpMethod": "PUT",
                            "id": "dreampipe_pa.domain.backfill.approval",
                            "parameterOrder": [
                                "domain"
                            ],
                            "parameters": {
                                "backfillId": {
                                    "location": "query",
                                    "type": "string"
                                },
                                "domain": {
                                    "location": "path",
                                    "pattern": "^[^/]+$",
                                    "required": true,
                                    "type": "string"
                                },
                                "version": {
                                    "location": "query",
                                    "type": "string"
                                }
                            },
                            "path": "v1/domain/{+domain}/backfill/approval",
                            "response": {
                                "$ref": "ApproveBackfillResponse"
                            },
                            "scopes": [
                                "https://www.googleapis.com/auth/plx"
                            ]
                        },
                        "proposal": {
                            "description": "Writes the proposal to Spanner. If this proposal already exists (has\nversion assigned), it gets updated. If the proposal does not exist, new one\nis created. Version is returned back in both cases.",
                            "flatPath": "v1/domain/{domainId}/backfill/proposal",
                            "httpMethod": "PUT",
                            "id": "dreampipe_pa.domain.backfill.proposal",
                            "parameterOrder": [
                                "domain"
                            ],
                            "parameters": {
                                "domain": {
                                    "location": "path",
                                    "pattern": "^[^/]+$",
                                    "required": true,
                                    "type": "string"
                                }
                            },
                            "path": "v1/domain/{+domain}/backfill/proposal",
                            "request": {
                                "$ref": "Backfill"
                            },
                            "response": {
                                "$ref": "ProposeBackfillResponse"
                            },
                            "scopes": [
                                "https://www.googleapis.com/auth/plx"
                            ]
                        }
                    },
                    "resources": {
                        "id": {
                            "methods": {
                                "backfill": {
                                    "description": "Return the data about the requested backfill.",
                                    "flatPath": "v1/domain/{domainId}/backfill/id/{backfillId}",
                                    "httpMethod": "GET",
                                    "id": "dreampipe_pa.domain.backfill.id.backfill",
                                    "parameterOrder": [
                                        "domain",
                                        "backfillId"
                                    ],
                                    "parameters": {
                                        "backfillId": {
                                            "location": "path",
                                            "required": true,
                                            "type": "string"
                                        },
                                        "domain": {
                                            "location": "path",
                                            "pattern": "^[^/]+$",
                                            "required": true,
                                            "type": "string"
                                        }
                                    },
                                    "path": "v1/domain/{+domain}/backfill/id/{backfillId}",
                                    "response": {
                                        "$ref": "BackfillResponse"
                                    },
                                    "scopes": [
                                        "https://www.googleapis.com/auth/plx"
                                    ]
                                }
                            }
                        }
                    }
                },
                "backfill_new": {
                    "methods": {
                        "list": {
                            "description": "Retrieve the metadata of all backfills satisfying the specified criteria.",
                            "flatPath": "v1/domain/{domainId}/backfill_new",
                            "httpMethod": "GET",
                            "id": "dreampipe_pa.domain.backfill_new.list",
                            "parameterOrder": [
                                "domain"
                            ],
                            "parameters": {
                                "backfillId": {
                                    "description": "If not specified, all backfills from the domain will be returned.",
                                    "format": "int64",
                                    "location": "query",
                                    "type": "string"
                                },
                                "domain": {
                                    "description": "Fully specified domain, needs to be specified.",
                                    "location": "path",
                                    "pattern": "^[^/]+$",
                                    "required": true,
                                    "type": "string"
                                }
                            },
                            "path": "v1/domain/{+domain}/backfill_new",
                            "response": {
                                "$ref": "DreampipeServer..ListBackfillsResponse"
                            },
                            "scopes": [
                                "https://www.googleapis.com/auth/plx"
                            ]
                        }
                    },
                    "resources": {
                        "id": {
                            "methods": {
                                "listBackfills": {
                                    "description": "Retrieve the metadata of all backfills satisfying the specified criteria.",
                                    "flatPath": "v1/domain/{domainId}/backfill_new/id/{idId}",
                                    "httpMethod": "GET",
                                    "id": "dreampipe_pa.domain.backfill_new.id.listBackfills",
                                    "parameterOrder": [
                                        "domain",
                                        "backfillId"
                                    ],
                                    "parameters": {
                                        "backfillId": {
                                            "description": "If not specified, all backfills from the domain will be returned.",
                                            "format": "int64",
                                            "location": "path",
                                            "pattern": "^[^/]+$",
                                            "required": true,
                                            "type": "string"
                                        },
                                        "domain": {
                                            "description": "Fully specified domain, needs to be specified.",
                                            "location": "path",
                                            "pattern": "^[^/]+$",
                                            "required": true,
                                            "type": "string"
                                        }
                                    },
                                    "path": "v1/domain/{+domain}/backfill_new/id/{+backfillId}",
                                    "response": {
                                        "$ref": "DreampipeServer..ListBackfillsResponse"
                                    },
                                    "scopes": [
                                        "https://www.googleapis.com/auth/plx"
                                    ]
                                }
                            },
                            "resources": {
                                "status": {
                                    "methods": {
                                        "setBackfillStatus": {
                                            "description": "Set the status of a backfill.",
                                            "flatPath": "v1/domain/{domainId}/backfill_new/id/{idId}/status/{statusId}",
                                            "httpMethod": "PUT",
                                            "id": "dreampipe_pa.domain.backfill_new.id.status.setBackfillStatus",
                                            "parameterOrder": [
                                                "domain",
                                                "backfillId",
                                                "status"
                                            ],
                                            "parameters": {
                                                "backfillId": {
                                                    "description": "Unique identifier of a backfill within a domain. This is a timestamp in\nmicroseconds assigned to a backfill by Dreampipe when its first version was\nproposed.",
                                                    "format": "int64",
                                                    "location": "path",
                                                    "pattern": "^[^/]+$",
                                                    "required": true,
                                                    "type": "string"
                                                },
                                                "domain": {
                                                    "description": "Domain of all outputs contained in the backfill. Backfill can only contain\noutputs from a single domain. This is a fully specified domain, it needs to\ninclude the subdomain as well if it is used. See OutputDef.domain for more\ndetails.",
                                                    "location": "path",
                                                    "pattern": "^[^/]+$",
                                                    "required": true,
                                                    "type": "string"
                                                },
                                                "status": {
                                                    "description": "Status to set for the specified backfill.",
                                                    "enum": [
                                                        "ACTIVE",
                                                        "DISABLED",
                                                        "PAUSED"
                                                    ],
                                                    "location": "path",
                                                    "pattern": "^[^/]+$",
                                                    "required": true,
                                                    "type": "string"
                                                }
                                            },
                                            "path": "v1/domain/{+domain}/backfill_new/id/{+backfillId}/status/{+status}",
                                            "response": {
                                                "$ref": "DreampipeServer..SetBackfillStatusResponse"
                                            },
                                            "scopes": [
                                                "https://www.googleapis.com/auth/plx"
                                            ]
                                        }
                                    }
                                }
                            }
                        }
                    }
                },
                "deployments": {
                    "methods": {
                        "list": {
                            "description": "Returns the deployments for a domain.",
                            "flatPath": "v1/domain/{domainId}/deployments",
                            "httpMethod": "GET",
                            "id": "dreampipe_pa.domain.deployments.list",
                            "parameterOrder": [
                                "domain"
                            ],
                            "parameters": {
                                "domain": {
                                    "location": "path",
                                    "pattern": "^[^/]+$",
                                    "required": true,
                                    "type": "string"
                                }
                            },
                            "path": "v1/domain/{+domain}/deployments",
                            "response": {
                                "$ref": "ListDeploymentsResponse"
                            },
                            "scopes": [
                                "https://www.googleapis.com/auth/plx"
                            ]
                        }
                    }
                },
                "mandate": {
                    "resources": {
                        "name": {
                            "methods": {
                                "getMonitoring": {
                                    "description": "Gets the monitoring configuration for a particular output. All monitoring\nis internally configured individually for each domain/mandate/output tuple\nsuch that all of them are mandatory.",
                                    "flatPath": "v1/domain/{domainId}/mandate/{mandateId}/name/{nameId}/monitoring",
                                    "httpMethod": "GET",
                                    "id": "dreampipe_pa.domain.mandate.name.getMonitoring",
                                    "parameterOrder": [
                                        "domain",
                                        "mandateId",
                                        "name"
                                    ],
                                    "parameters": {
                                        "domain": {
                                            "location": "path",
                                            "pattern": "^[^/]+$",
                                            "required": true,
                                            "type": "string"
                                        },
                                        "mandateId": {
                                            "location": "path",
                                            "pattern": "^[^/]+$",
                                            "required": true,
                                            "type": "string"
                                        },
                                        "name": {
                                            "location": "path",
                                            "pattern": "^[^/]+$",
                                            "required": true,
                                            "type": "string"
                                        }
                                    },
                                    "path": "v1/domain/{+domain}/mandate/{+mandateId}/name/{+name}/monitoring",
                                    "response": {
                                        "$ref": "MonitoringConfig"
                                    },
                                    "scopes": [
                                        "https://www.googleapis.com/auth/plx"
                                    ]
                                },
                                "history": {
                                    "description": "Return the execution history of a Dreampipe job.",
                                    "flatPath": "v1/domain/{domainId}/mandate/{mandateId}/name/{nameId}/history",
                                    "httpMethod": "GET",
                                    "id": "dreampipe_pa.domain.mandate.name.history",
                                    "parameterOrder": [
                                        "domain",
                                        "mandateId",
                                        "name"
                                    ],
                                    "parameters": {
                                        "domain": {
                                            "location": "path",
                                            "pattern": "^[^/]+$",
                                            "required": true,
                                            "type": "string"
                                        },
                                        "instanceIds": {
                                            "description": "If specified, only entries for these instances will be retrieved, otherwise\nall instances will be retrieved.",
                                            "location": "query",
                                            "repeated": true,
                                            "type": "string"
                                        },
                                        "mandateId": {
                                            "description": "If set, only executions contributing to the current configuration of this\nmandate will be returned. Otherwise, all executions will be.",
                                            "location": "path",
                                            "pattern": "^[^/]+$",
                                            "required": true,
                                            "type": "string"
                                        },
                                        "maxHistoryAge": {
                                            "format": "int32",
                                            "location": "query",
                                            "type": "integer"
                                        },
                                        "name": {
                                            "location": "path",
                                            "pattern": "^[^/]+$",
                                            "required": true,
                                            "type": "string"
                                        }
                                    },
                                    "path": "v1/domain/{+domain}/mandate/{+mandateId}/name/{+name}/history",
                                    "response": {
                                        "$ref": "ExecutionHistoryResponse"
                                    },
                                    "scopes": [
                                        "https://www.googleapis.com/auth/plx"
                                    ]
                                },
                                "instances": {
                                    "description": "Return the status of each OutputInstance associated with this job: this\nshows the disposition of the *output data*.",
                                    "flatPath": "v1/domain/{domainId}/mandate/{mandateId}/name/{nameId}/instances",
                                    "httpMethod": "GET",
                                    "id": "dreampipe_pa.domain.mandate.name.instances",
                                    "parameterOrder": [
                                        "domain",
                                        "mandateId",
                                        "name"
                                    ],
                                    "parameters": {
                                        "domain": {
                                            "location": "path",
                                            "pattern": "^[^/]+$",
                                            "required": true,
                                            "type": "string"
                                        },
                                        "mandateId": {
                                            "description": "If set, only returns OutputInstance status applicable to a specific\nmandate. Otherwise returns all instances.",
                                            "location": "path",
                                            "pattern": "^[^/]+$",
                                            "required": true,
                                            "type": "string"
                                        },
                                        "name": {
                                            "location": "path",
                                            "pattern": "^[^/]+$",
                                            "required": true,
                                            "type": "string"
                                        }
                                    },
                                    "path": "v1/domain/{+domain}/mandate/{+mandateId}/name/{+name}/instances",
                                    "response": {
                                        "$ref": "OutputInstanceStatusResponse"
                                    },
                                    "scopes": [
                                        "https://www.googleapis.com/auth/plx"
                                    ]
                                }
                            },
                            "resources": {
                                "instance": {
                                    "methods": {
                                        "getGraph": {
                                            "description": "Returns the computation graph for the specified instance. The graph\nshows the hierarchy and the state of the individual dependencies for the\ncomputation.",
                                            "flatPath": "v1/domain/{domainId}/mandate/{mandateId}/name/{nameId}/instance/{instanceId}/graph",
                                            "httpMethod": "GET",
                                            "id": "dreampipe_pa.domain.mandate.name.instance.getGraph",
                                            "parameterOrder": [
                                                "domain",
                                                "mandateId",
                                                "name",
                                                "instanceId"
                                            ],
                                            "parameters": {
                                                "backfillId": {
                                                    "description": "Optionally check if all instances fulfill the specified backfill id or not.",
                                                    "format": "int64",
                                                    "location": "query",
                                                    "type": "string"
                                                },
                                                "domain": {
                                                    "description": "Domain, output_name and instance_id params uniquely identify an instance.",
                                                    "location": "path",
                                                    "pattern": "^[^/]+$",
                                                    "required": true,
                                                    "type": "string"
                                                },
                                                "instanceId": {
                                                    "location": "path",
                                                    "pattern": "^[^/]+$",
                                                    "required": true,
                                                    "type": "string"
                                                },
                                                "mandateId": {
                                                    "location": "path",
                                                    "pattern": "^[^/]+$",
                                                    "required": true,
                                                    "type": "string"
                                                },
                                                "name": {
                                                    "location": "path",
                                                    "pattern": "^[^/]+$",
                                                    "required": true,
                                                    "type": "string"
                                                },
                                                "timestamp": {
                                                    "description": "Optionally retrieves a stored snapshot that was created e.g. in response to\nan alert for delayed partitions. Only timestamps for existing snapshots are\nallowed. If timestamp is not set, the response will reflect the current\nstate of the instance. This is in seconds since epoch.",
                                                    "format": "int64",
                                                    "location": "query",
                                                    "type": "string"
                                                }
                                            },
                                            "path": "v1/domain/{+domain}/mandate/{+mandateId}/name/{+name}/instance/{+instanceId}/graph",
                                            "response": {
                                                "$ref": "GetComputationGraphResponse"
                                            },
                                            "scopes": [
                                                "https://www.googleapis.com/auth/plx"
                                            ]
                                        }
                                    },
                                    "resources": {
                                        "graphs": {
                                            "methods": {
                                                "list": {
                                                    "description": "List all computation graph filtering options of a particular instance.",
                                                    "flatPath": "v1/domain/{domainId}/mandate/{mandateId}/name/{nameId}/instance/{instanceId}/graphs",
                                                    "httpMethod": "GET",
                                                    "id": "dreampipe_pa.domain.mandate.name.instance.graphs.list",
                                                    "parameterOrder": [
                                                        "domain",
                                                        "mandateId",
                                                        "name",
                                                        "instanceId"
                                                    ],
                                                    "parameters": {
                                                        "domain": {
                                                            "description": "Domain, output_name and instance_id params uniquely identify an instance.",
                                                            "location": "path",
                                                            "pattern": "^[^/]+$",
                                                            "required": true,
                                                            "type": "string"
                                                        },
                                                        "instanceId": {
                                                            "location": "path",
                                                            "pattern": "^[^/]+$",
                                                            "required": true,
                                                            "type": "string"
                                                        },
                                                        "mandateId": {
                                                            "location": "path",
                                                            "pattern": "^[^/]+$",
                                                            "required": true,
                                                            "type": "string"
                                                        },
                                                        "name": {
                                                            "location": "path",
                                                            "pattern": "^[^/]+$",
                                                            "required": true,
                                                            "type": "string"
                                                        }
                                                    },
                                                    "path": "v1/domain/{+domain}/mandate/{+mandateId}/name/{+name}/instance/{+instanceId}/graphs",
                                                    "response": {
                                                        "$ref": "ListComputationGraphsResponse"
                                                    },
                                                    "scopes": [
                                                        "https://www.googleapis.com/auth/plx"
                                                    ]
                                                }
                                            }
                                        },
                                        "queueStatus": {
                                            "methods": {
                                                "search": {
                                                    "description": "Searches for all launchers that queue the requested output instance.\nResponds with information about the queue and position of the output\ninstance if requested.",
                                                    "flatPath": "v1/domain/{domainId}/mandate/{mandateId}/name/{nameId}/instance/{instanceId}/queueStatus:search",
                                                    "httpMethod": "GET",
                                                    "id": "dreampipe_pa.domain.mandate.name.instance.queueStatus.search",
                                                    "parameterOrder": [
                                                        "domain",
                                                        "mandateId",
                                                        "name",
                                                        "instanceId"
                                                    ],
                                                    "parameters": {
                                                        "domain": {
                                                            "location": "path",
                                                            "pattern": "^[^/]+$",
                                                            "required": true,
                                                            "type": "string"
                                                        },
                                                        "instanceId": {
                                                            "location": "path",
                                                            "pattern": "^[^/]+$",
                                                            "required": true,
                                                            "type": "string"
                                                        },
                                                        "mandateId": {
                                                            "description": "Optional. If not set queues are matched against empty mandate only.",
                                                            "location": "path",
                                                            "pattern": "^[^/]+$",
                                                            "required": true,
                                                            "type": "string"
                                                        },
                                                        "name": {
                                                            "location": "path",
                                                            "pattern": "^[^/]+$",
                                                            "required": true,
                                                            "type": "string"
                                                        }
                                                    },
                                                    "path": "v1/domain/{+domain}/mandate/{+mandateId}/name/{+name}/instance/{+instanceId}/queueStatus:search",
                                                    "response": {
                                                        "$ref": "SearchQueueStatusResponse"
                                                    },
                                                    "scopes": [
                                                        "https://www.googleapis.com/auth/plx"
                                                    ]
                                                }
                                            }
                                        }
                                    }
                                },
                                "instances": {
                                    "methods": {
                                        "listSummary": {
                                            "description": "Return the status of each OutputInstance associated with this job, newest\nfirst. This shows the disposition of the output data and the job associated\nwith it.\n\nFor outputs with high periodicity (> one instance per hour), this will\nonly return instances for which Dreampipe has attempted a computation.\nOtherwise, it will return all instances for which a computation could\noccur.",
                                            "flatPath": "v1/domain/{domainId}/mandate/{mandateId}/name/{nameId}/instances:summary",
                                            "httpMethod": "GET",
                                            "id": "dreampipe_pa.domain.mandate.name.instances.listSummary",
                                            "parameterOrder": [
                                                "domain",
                                                "mandateId",
                                                "name"
                                            ],
                                            "parameters": {
                                                "domain": {
                                                    "location": "path",
                                                    "pattern": "^[^/]+$",
                                                    "required": true,
                                                    "type": "string"
                                                },
                                                "endTime": {
                                                    "location": "query",
                                                    "type": "string"
                                                },
                                                "instanceIds": {
                                                    "description": "Optional list of instance identifiers allowing to select only particular\ninstances.",
                                                    "location": "query",
                                                    "repeated": true,
                                                    "type": "string"
                                                },
                                                "mandateId": {
                                                    "description": "If set, only returns OutputInstance status applicable to a specific\nmandate. Otherwise returns all instances.",
                                                    "location": "path",
                                                    "pattern": "^[^/]+$",
                                                    "required": true,
                                                    "type": "string"
                                                },
                                                "name": {
                                                    "location": "path",
                                                    "pattern": "^[^/]+$",
                                                    "required": true,
                                                    "type": "string"
                                                },
                                                "oldestFirst": {
                                                    "description": "By default, the call returns instances in sorted order with the most recent\ninstance first. Setting this option will return the oldest_first.",
                                                    "location": "query",
                                                    "type": "boolean"
                                                },
                                                "pageSize": {
                                                    "description": "Restricts the response to page_size results starting at page_token.",
                                                    "format": "int32",
                                                    "location": "query",
                                                    "type": "integer"
                                                },
                                                "pageToken": {
                                                    "location": "query",
                                                    "type": "string"
                                                },
                                                "startTime": {
                                                    "description": "Restrict to start_time <= instance time < end_time. Applied before\npage_size/page_token. By default, the range is from the domains start date\nuntil the current time. Setting start/end time outside this boundaries will\nnot change the results. It is also valid to set only one of them.",
                                                    "location": "query",
                                                    "type": "string"
                                                }
                                            },
                                            "path": "v1/domain/{+domain}/mandate/{+mandateId}/name/{+name}/instances:summary",
                                            "response": {
                                                "$ref": "ListInstancesResponse"
                                            },
                                            "scopes": [
                                                "https://www.googleapis.com/auth/plx"
                                            ]
                                        }
                                    }
                                }
                            }
                        },
                        "permissions": {
                            "methods": {
                                "test": {
                                    "description": "Checks whether the calling user or a prod group that they belong to has\nbeen granted specified roles. Response returns a subset of the roles that\nhave been granted.",
                                    "flatPath": "v1/domain/{domainId}/mandate/{mandateId}/permissions:test",
                                    "httpMethod": "POST",
                                    "id": "dreampipe_pa.domain.mandate.permissions.test",
                                    "parameterOrder": [
                                        "domain",
                                        "mandateId"
                                    ],
                                    "parameters": {
                                        "domain": {
                                            "description": "Domain of all outputs contained within the mandate. Mandate can only\ncontain outputs from a single domain. This is a fully specified domain, it\nneeds to include the subdomain as well if it is used.",
                                            "location": "path",
                                            "pattern": "^[^/]+$",
                                            "required": true,
                                            "type": "string"
                                        },
                                        "mandateId": {
                                            "description": "Unique identifier of a mandate within the domain.",
                                            "location": "path",
                                            "pattern": "^[^/]+$",
                                            "required": true,
                                            "type": "string"
                                        },
                                        "roles": {
                                            "enum": [
                                                "ROLE_UNKNOWN",
                                                "ROLE_DOMAIN_READER",
                                                "ROLE_DOMAIN_WRITER",
                                                "ROLE_MANDATE_READER",
                                                "ROLE_MANDATE_WRITER",
                                                "ROLE_BACKFILL_READER",
                                                "ROLE_BACKFILL_WRITER",
                                                "ROLE_RETENTION_READER",
                                                "ROLE_RETENTION_WRITER",
                                                "ROLE_LAUNCHER_POOL_WRITER",
                                                "ROLE_OUTPUT_READER",
                                                "ROLE_OUTPUT_WRITER",
                                                "ROLE_INSTANCE_READER",
                                                "ROLE_EXEC_ATTEMPTS_WRITER",
                                                "ROLE_SCHEDULING_STATUS_READER",
                                                "ROLE_SCHEDULING_STATUS_WRITER"
                                            ],
                                            "location": "query",
                                            "repeated": true,
                                            "type": "string"
                                        },
                                        "target.domain": {
                                            "description": "RPCs targeting this domain are allowed to be invoked.",
                                            "location": "query",
                                            "type": "string"
                                        },
                                        "target.launcherPoolId": {
                                            "description": "RPCs targeting this launcher pool are allowed to be invoked.",
                                            "location": "query",
                                            "type": "string"
                                        }
                                    },
                                    "path": "v1/domain/{+domain}/mandate/{+mandateId}/permissions:test",
                                    "response": {
                                        "$ref": "DreampipeInternalRestrictedApi..TestPermissionsResponse"
                                    },
                                    "scopes": [
                                        "https://www.googleapis.com/auth/plx"
                                    ]
                                }
                            }
                        }
                    }
                },
                "mandates": {
                    "methods": {
                        "list": {
                            "description": "List mandates satisfying the specified filter. See\nmandate.proto/ListMandatesRequest for more details.\n\n[Deprecated] This call may return incorrect data and has been replaced with\nListDeployments().",
                            "flatPath": "v1/domain/{domainId}/mandates",
                            "httpMethod": "GET",
                            "id": "dreampipe_pa.domain.mandates.list",
                            "parameterOrder": [
                                "domain"
                            ],
                            "parameters": {
                                "domain": {
                                    "description": "Domain from which to list the mandates. This is a required field.",
                                    "location": "path",
                                    "pattern": "^[^/]+$",
                                    "required": true,
                                    "type": "string"
                                },
                                "mandateId": {
                                    "description": "If not specified, all mandates from the domain will be returned.",
                                    "location": "query",
                                    "type": "string"
                                },
                                "maxNumMandateVersions": {
                                    "description": "If specified, limits the number of versions returned in MandateInfo.\nThe older versions are truncated first.",
                                    "format": "int32",
                                    "location": "query",
                                    "type": "integer"
                                },
                                "status": {
                                    "description": "If specified, the result will be further filtered to contain only mandates\nwith this status.",
                                    "enum": [
                                        "STATUS_UNKNOWN",
                                        "STATUS_ACTIVE",
                                        "STATUS_DISABLED"
                                    ],
                                    "location": "query",
                                    "type": "string"
                                }
                            },
                            "path": "v1/domain/{+domain}/mandates",
                            "response": {
                                "$ref": "DreampipeServer..ListMandatesResponse"
                            },
                            "scopes": [
                                "https://www.googleapis.com/auth/plx"
                            ]
                        }
                    }
                },
                "name": {
                    "methods": {
                        "backfills": {
                            "description": "Returns all backfills satisfying the condition.",
                            "flatPath": "v1/domain/{domainId}/name/{output}/backfills",
                            "httpMethod": "GET",
                            "id": "dreampipe_pa.domain.name.backfills",
                            "parameterOrder": [
                                "domain",
                                "output"
                            ],
                            "parameters": {
                                "domain": {
                                    "location": "path",
                                    "pattern": "^[^/]+$",
                                    "required": true,
                                    "type": "string"
                                },
                                "output": {
                                    "description": "All backfills whose latest approved or the currently proposed version\ninclude this output.",
                                    "location": "path",
                                    "required": true,
                                    "type": "string"
                                }
                            },
                            "path": "v1/domain/{+domain}/name/{output}/backfills",
                            "response": {
                                "$ref": "SearchBackfillsResponse"
                            },
                            "scopes": [
                                "https://www.googleapis.com/auth/plx"
                            ]
                        },
                        "getMonitoring": {
                            "description": "Gets the monitoring configuration for a particular output. All monitoring\nis internally configured individually for each domain/mandate/output tuple\nsuch that all of them are mandatory.",
                            "flatPath": "v1/domain/{domainId}/name/{nameId}/monitoring",
                            "httpMethod": "GET",
                            "id": "dreampipe_pa.domain.name.getMonitoring",
                            "parameterOrder": [
                                "domain",
                                "name"
                            ],
                            "parameters": {
                                "domain": {
                                    "location": "path",
                                    "pattern": "^[^/]+$",
                                    "required": true,
                                    "type": "string"
                                },
                                "mandateId": {
                                    "location": "query",
                                    "type": "string"
                                },
                                "name": {
                                    "location": "path",
                                    "pattern": "^[^/]+$",
                                    "required": true,
                                    "type": "string"
                                }
                            },
                            "path": "v1/domain/{+domain}/name/{+name}/monitoring",
                            "response": {
                                "$ref": "MonitoringConfig"
                            },
                            "scopes": [
                                "https://www.googleapis.com/auth/plx"
                            ]
                        },
                        "getStatus": {
                            "description": "Get the scheduling status for the specified output definition.",
                            "flatPath": "v1/domain/{domainId}/name/{nameId}/status",
                            "httpMethod": "GET",
                            "id": "dreampipe_pa.domain.name.getStatus",
                            "parameterOrder": [
                                "domain",
                                "name"
                            ],
                            "parameters": {
                                "domain": {
                                    "location": "path",
                                    "pattern": "^[^/]+$",
                                    "required": true,
                                    "type": "string"
                                },
                                "mandateId": {
                                    "description": "If set, the status is resolved within the provided mandate,",
                                    "location": "query",
                                    "type": "string"
                                },
                                "name": {
                                    "location": "path",
                                    "pattern": "^[^/]+$",
                                    "required": true,
                                    "type": "string"
                                },
                                "timestamp": {
                                    "format": "int64",
                                    "location": "query",
                                    "type": "string"
                                }
                            },
                            "path": "v1/domain/{+domain}/name/{+name}/status",
                            "response": {
                                "$ref": "DreampipeInternalRestrictedApi..GetOutputDefSchedulingStatusResponse"
                            },
                            "scopes": [
                                "https://www.googleapis.com/auth/plx"
                            ]
                        },
                        "history": {
                            "description": "Return the execution history of a Dreampipe job.",
                            "flatPath": "v1/domain/{domainId}/name/{nameId}/history",
                            "httpMethod": "GET",
                            "id": "dreampipe_pa.domain.name.history",
                            "parameterOrder": [
                                "domain",
                                "name"
                            ],
                            "parameters": {
                                "domain": {
                                    "location": "path",
                                    "pattern": "^[^/]+$",
                                    "required": true,
                                    "type": "string"
                                },
                                "instanceIds": {
                                    "description": "If specified, only entries for these instances will be retrieved, otherwise\nall instances will be retrieved.",
                                    "location": "query",
                                    "repeated": true,
                                    "type": "string"
                                },
                                "mandateId": {
                                    "description": "If set, only executions contributing to the current configuration of this\nmandate will be returned. Otherwise, all executions will be.",
                                    "location": "query",
                                    "type": "string"
                                },
                                "maxHistoryAge": {
                                    "format": "int32",
                                    "location": "query",
                                    "type": "integer"
                                },
                                "name": {
                                    "location": "path",
                                    "pattern": "^[^/]+$",
                                    "required": true,
                                    "type": "string"
                                }
                            },
                            "path": "v1/domain/{+domain}/name/{+name}/history",
                            "response": {
                                "$ref": "ExecutionHistoryResponse"
                            },
                            "scopes": [
                                "https://www.googleapis.com/auth/plx"
                            ]
                        },
                        "instances": {
                            "description": "Return the status of each OutputInstance associated with this job: this\nshows the disposition of the *output data*.",
                            "flatPath": "v1/domain/{domainId}/name/{nameId}/instances",
                            "httpMethod": "GET",
                            "id": "dreampipe_pa.domain.name.instances",
                            "parameterOrder": [
                                "domain",
                                "name"
                            ],
                            "parameters": {
                                "domain": {
                                    "location": "path",
                                    "pattern": "^[^/]+$",
                                    "required": true,
                                    "type": "string"
                                },
                                "mandateId": {
                                    "description": "If set, only returns OutputInstance status applicable to a specific\nmandate. Otherwise returns all instances.",
                                    "location": "query",
                                    "type": "string"
                                },
                                "name": {
                                    "location": "path",
                                    "pattern": "^[^/]+$",
                                    "required": true,
                                    "type": "string"
                                }
                            },
                            "path": "v1/domain/{+domain}/name/{+name}/instances",
                            "response": {
                                "$ref": "OutputInstanceStatusResponse"
                            },
                            "scopes": [
                                "https://www.googleapis.com/auth/plx"
                            ]
                        },
                        "reset": {
                            "description": "Override the attempt count for specified output instances.",
                            "flatPath": "v1/domain/{domainId}/name/{nameId}/reset",
                            "httpMethod": "PUT",
                            "id": "dreampipe_pa.domain.name.reset",
                            "parameterOrder": [
                                "domain",
                                "output"
                            ],
                            "parameters": {
                                "domain": {
                                    "location": "path",
                                    "pattern": "^[^/]+$",
                                    "required": true,
                                    "type": "string"
                                },
                                "output": {
                                    "location": "path",
                                    "pattern": "^[^/]+$",
                                    "required": true,
                                    "type": "string"
                                }
                            },
                            "path": "v1/domain/{+domain}/name/{+output}/reset",
                            "request": {
                                "$ref": "DreampipeInternalRestrictedApi..OverrideAttemptCountRequest"
                            },
                            "response": {
                                "$ref": "DreampipeInternalRestrictedApi..OverrideAttemptCountResponse"
                            },
                            "scopes": [
                                "https://www.googleapis.com/auth/plx"
                            ]
                        },
                        "running": {
                            "description": "Return a set of running tasks for an outputdef.",
                            "flatPath": "v1/domain/{domainId}/name/{nameId}/running",
                            "httpMethod": "GET",
                            "id": "dreampipe_pa.domain.name.running",
                            "parameterOrder": [
                                "domain",
                                "name"
                            ],
                            "parameters": {
                                "domain": {
                                    "location": "path",
                                    "pattern": "^[^/]+$",
                                    "required": true,
                                    "type": "string"
                                },
                                "name": {
                                    "location": "path",
                                    "pattern": "^[^/]+$",
                                    "required": true,
                                    "type": "string"
                                }
                            },
                            "path": "v1/domain/{+domain}/name/{+name}/running",
                            "response": {
                                "$ref": "RunningTasksLookupResponse"
                            },
                            "scopes": [
                                "https://www.googleapis.com/auth/plx"
                            ]
                        },
                        "status": {
                            "description": "Set the scheduling status for the specified output definition.",
                            "flatPath": "v1/domain/{domainId}/name/{nameId}/status",
                            "httpMethod": "PUT",
                            "id": "dreampipe_pa.domain.name.status",
                            "parameterOrder": [
                                "domain",
                                "name"
                            ],
                            "parameters": {
                                "domain": {
                                    "location": "path",
                                    "pattern": "^[^/]+$",
                                    "required": true,
                                    "type": "string"
                                },
                                "name": {
                                    "location": "path",
                                    "pattern": "^[^/]+$",
                                    "required": true,
                                    "type": "string"
                                }
                            },
                            "path": "v1/domain/{+domain}/name/{+name}/status",
                            "request": {
                                "$ref": "DreampipeInternalRestrictedApi..SetOutputDefSchedulingStatusRequest"
                            },
                            "response": {
                                "$ref": "DreampipeInternalRestrictedApi..SetOutputDefSchedulingStatusResponse"
                            },
                            "scopes": [
                                "https://www.googleapis.com/auth/plx"
                            ]
                        }
                    },
                    "resources": {
                        "instance": {
                            "resources": {
                                "queueStatus": {
                                    "methods": {
                                        "search": {
                                            "description": "Searches for all launchers that queue the requested output instance.\nResponds with information about the queue and position of the output\ninstance if requested.",
                                            "flatPath": "v1/domain/{domainId}/name/{nameId}/instance/{instanceId}/queueStatus:search",
                                            "httpMethod": "GET",
                                            "id": "dreampipe_pa.domain.name.instance.queueStatus.search",
                                            "parameterOrder": [
                                                "domain",
                                                "name",
                                                "instanceId"
                                            ],
                                            "parameters": {
                                                "domain": {
                                                    "location": "path",
                                                    "pattern": "^[^/]+$",
                                                    "required": true,
                                                    "type": "string"
                                                },
                                                "instanceId": {
                                                    "location": "path",
                                                    "pattern": "^[^/]+$",
                                                    "required": true,
                                                    "type": "string"
                                                },
                                                "mandateId": {
                                                    "description": "Optional. If not set queues are matched against empty mandate only.",
                                                    "location": "query",
                                                    "type": "string"
                                                },
                                                "name": {
                                                    "location": "path",
                                                    "pattern": "^[^/]+$",
                                                    "required": true,
                                                    "type": "string"
                                                }
                                            },
                                            "path": "v1/domain/{+domain}/name/{+name}/instance/{+instanceId}/queueStatus:search",
                                            "response": {
                                                "$ref": "SearchQueueStatusResponse"
                                            },
                                            "scopes": [
                                                "https://www.googleapis.com/auth/plx"
                                            ]
                                        }
                                    }
                                }
                            }
                        },
                        "instances": {
                            "methods": {
                                "listSummary": {
                                    "description": "Return the status of each OutputInstance associated with this job, newest\nfirst. This shows the disposition of the output data and the job associated\nwith it.\n\nFor outputs with high periodicity (> one instance per hour), this will\nonly return instances for which Dreampipe has attempted a computation.\nOtherwise, it will return all instances for which a computation could\noccur.",
                                    "flatPath": "v1/domain/{domainId}/name/{nameId}/instances:summary",
                                    "httpMethod": "GET",
                                    "id": "dreampipe_pa.domain.name.instances.listSummary",
                                    "parameterOrder": [
                                        "domain",
                                        "name"
                                    ],
                                    "parameters": {
                                        "domain": {
                                            "location": "path",
                                            "pattern": "^[^/]+$",
                                            "required": true,
                                            "type": "string"
                                        },
                                        "endTime": {
                                            "location": "query",
                                            "type": "string"
                                        },
                                        "instanceIds": {
                                            "description": "Optional list of instance identifiers allowing to select only particular\ninstances.",
                                            "location": "query",
                                            "repeated": true,
                                            "type": "string"
                                        },
                                        "mandateId": {
                                            "description": "If set, only returns OutputInstance status applicable to a specific\nmandate. Otherwise returns all instances.",
                                            "location": "query",
                                            "type": "string"
                                        },
                                        "name": {
                                            "location": "path",
                                            "pattern": "^[^/]+$",
                                            "required": true,
                                            "type": "string"
                                        },
                                        "oldestFirst": {
                                            "description": "By default, the call returns instances in sorted order with the most recent\ninstance first. Setting this option will return the oldest_first.",
                                            "location": "query",
                                            "type": "boolean"
                                        },
                                        "pageSize": {
                                            "description": "Restricts the response to page_size results starting at page_token.",
                                            "format": "int32",
                                            "location": "query",
                                            "type": "integer"
                                        },
                                        "pageToken": {
                                            "location": "query",
                                            "type": "string"
                                        },
                                        "startTime": {
                                            "description": "Restrict to start_time <= instance time < end_time. Applied before\npage_size/page_token. By default, the range is from the domains start date\nuntil the current time. Setting start/end time outside this boundaries will\nnot change the results. It is also valid to set only one of them.",
                                            "location": "query",
                                            "type": "string"
                                        }
                                    },
                                    "path": "v1/domain/{+domain}/name/{+name}/instances:summary",
                                    "response": {
                                        "$ref": "ListInstancesResponse"
                                    },
                                    "scopes": [
                                        "https://www.googleapis.com/auth/plx"
                                    ]
                                }
                            }
                        }
                    }
                },
                "notifications": {
                    "methods": {
                        "list": {
                            "description": "List currently active notifications for a domain. Notifications let the\nowner know of some less-than-optimal state of an entity within the domain\nand have different severities.",
                            "flatPath": "v1/domain/{domainId}/notifications",
                            "httpMethod": "GET",
                            "id": "dreampipe_pa.domain.notifications.list",
                            "parameterOrder": [
                                "domain"
                            ],
                            "parameters": {
                                "domain": {
                                    "location": "path",
                                    "pattern": "^[^/]+$",
                                    "required": true,
                                    "type": "string"
                                },
                                "input": {
                                    "description": "Optionally restrict response to a particular input. Requires \u2018output\u2019 to\nbe set. Will return all inputs if not set.",
                                    "location": "query",
                                    "type": "string"
                                },
                                "mandateId": {
                                    "location": "query",
                                    "type": "string"
                                },
                                "output": {
                                    "description": "Optionally restrict response to a particular output. Will return alerts\nfor all outputs if not set.",
                                    "location": "query",
                                    "type": "string"
                                }
                            },
                            "path": "v1/domain/{+domain}/notifications",
                            "response": {
                                "$ref": "ListNotificationsResponse"
                            },
                            "scopes": [
                                "https://www.googleapis.com/auth/plx"
                            ]
                        }
                    }
                },
                "outputs": {
                    "methods": {
                        "delete": {
                            "description": "DeleteOutputs deletes the specified outputs from a single domain. This\nincludes all of the outputs' definitions and instances. If dry run flag is\nset, the amount of data to delete will be computed, but nothing will be\nactually deleted. Outputs that were used as input for other outputs that\nare still relevant should not be deleted.",
                            "flatPath": "v1/domain/{domainId}/outputs:delete",
                            "httpMethod": "POST",
                            "id": "dreampipe_pa.domain.outputs.delete",
                            "parameterOrder": [
                                "domain"
                            ],
                            "parameters": {
                                "domain": {
                                    "location": "path",
                                    "pattern": "^[^/]+$",
                                    "required": true,
                                    "type": "string"
                                }
                            },
                            "path": "v1/domain/{+domain}/outputs:delete",
                            "request": {
                                "$ref": "DreampipeInternalRestrictedApi..OutputDeletionRequest"
                            },
                            "response": {
                                "$ref": "DreampipeInternalRestrictedApi..OutputDeletionResponse"
                            },
                            "scopes": [
                                "https://www.googleapis.com/auth/plx"
                            ]
                        }
                    }
                },
                "permissions": {
                    "methods": {
                        "test": {
                            "description": "Checks whether the calling user or a prod group that they belong to has\nbeen granted specified roles. Response returns a subset of the roles that\nhave been granted.",
                            "flatPath": "v1/domain/{domainId}/permissions:test",
                            "httpMethod": "POST",
                            "id": "dreampipe_pa.domain.permissions.test",
                            "parameterOrder": [
                                "domain"
                            ],
                            "parameters": {
                                "domain": {
                                    "description": "RPCs targeting this domain are allowed to be invoked.",
                                    "location": "path",
                                    "pattern": "^[^/]+$",
                                    "required": true,
                                    "type": "string"
                                }
                            },
                            "path": "v1/domain/{+domain}/permissions:test",
                            "request": {
                                "$ref": "DreampipeInternalRestrictedApi..TestPermissionsRequest"
                            },
                            "response": {
                                "$ref": "DreampipeInternalRestrictedApi..TestPermissionsResponse"
                            },
                            "scopes": [
                                "https://www.googleapis.com/auth/plx"
                            ]
                        }
                    }
                }
            }
        },
        "domains": {
            "methods": {
                "list": {
                    "description": "Returns the domains that the user has access to.",
                    "flatPath": "v1/domains",
                    "httpMethod": "GET",
                    "id": "dreampipe_pa.domains.list",
                    "parameterOrder": [],
                    "parameters": {},
                    "path": "v1/domains",
                    "response": {
                        "$ref": "ListDomainsResponse"
                    },
                    "scopes": [
                        "https://www.googleapis.com/auth/plx"
                    ]
                }
            }
        },
        "instances": {
            "methods": {
                "markComplete": {
                    "description": "Mark specified output instances as completed.",
                    "flatPath": "v1/instances:markComplete",
                    "httpMethod": "PATCH",
                    "id": "dreampipe_pa.instances.markComplete",
                    "parameterOrder": [],
                    "parameters": {},
                    "path": "v1/instances:markComplete",
                    "request": {
                        "$ref": "MarkInstancesCompleteRequest"
                    },
                    "response": {
                        "$ref": "MarkInstancesCompleteResponse"
                    },
                    "scopes": [
                        "https://www.googleapis.com/auth/plx"
                    ]
                }
            }
        },
        "lookup": {
            "methods": {
                "outputs": {
                    "description": "Use the BulkLookupOutputs call to retrieve OutputDefs belonging to an\nspecified outputs.",
                    "flatPath": "v1/lookup/outputs",
                    "httpMethod": "POST",
                    "id": "dreampipe_pa.lookup.outputs",
                    "parameterOrder": [],
                    "parameters": {},
                    "path": "v1/lookup/outputs",
                    "request": {
                        "$ref": "DreampipeServer..BulkOutputLookup"
                    },
                    "response": {
                        "$ref": "DreampipeServer..BulkOutputLookupResponse"
                    },
                    "scopes": [
                        "https://www.googleapis.com/auth/plx"
                    ]
                }
            }
        },
        "search": {
            "methods": {
                "active_locks": {
                    "description": "Returns the list of currently active (valid) locks.\nNOTE: This is used externally by play-analytics-experiments, POC: mleyton@",
                    "flatPath": "v1/search/active_locks",
                    "httpMethod": "GET",
                    "id": "dreampipe_pa.search.active_locks",
                    "parameterOrder": [],
                    "parameters": {
                        "domainFilter": {
                            "description": "Domain filter. Empty means no restriction, non-empty returns domain and all\nsub-domains. For example \"mdb/foo\" matches \"mdb/foo/bar\" but not\n\"mdb/foobar\".",
                            "location": "query",
                            "type": "string"
                        }
                    },
                    "path": "v1/search/active_locks",
                    "response": {
                        "$ref": "QueryActiveLocksResponse"
                    },
                    "scopes": [
                        "https://www.googleapis.com/auth/plx"
                    ]
                }
            }
        },
        "user": {
            "resources": {
                "current": {
                    "methods": {
                        "domains": {
                            "description": "Returns the domains and outputs that the user has access to and the\ninstantiations of these outputs for the last 4 days.",
                            "flatPath": "v1/user/current/domains",
                            "httpMethod": "GET",
                            "id": "dreampipe_pa.user.current.domains",
                            "parameterOrder": [],
                            "parameters": {},
                            "path": "v1/user/current/domains",
                            "response": {
                                "$ref": "UserDomainsWithRecentHistoryResponse"
                            },
                            "scopes": [
                                "https://www.googleapis.com/auth/plx"
                            ]
                        }
                    }
                }
            }
        }
    },
    "revision": "20190925",
    "rootUrl": "https://staging-dreampipe-pa.sandbox.googleapis.com/",
    "schemas": {
        "AnalysisResult": {
            "description": "TODO(mpinzaru) AnalysisResult is work in progress.",
            "id": "AnalysisResult",
            "properties": {
                "causeNodeIndex": {
                    "description": "Index of a computation node that is one of the failure reasons for the\ncomputation. This index must appear in the computation_node_index of the\nnode referred to by graph_node_id",
                    "items": {
                        "format": "uint64",
                        "type": "string"
                    },
                    "type": "array"
                },
                "graphNodeId": {
                    "description": "Id of a graph node whose availability is affected by the computation\nnodes.",
                    "type": "string"
                },
                "message": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "ApproveBackfillResponse": {
            "id": "ApproveBackfillResponse",
            "properties": {
                "approvedBy": {
                    "$ref": "UserTimestamp"
                }
            },
            "type": "object"
        },
        "Backfill": {
            "description": "Backfill corresponds to a BackfillRequest in Spanner which in turn represents\na single version of a backfill.",
            "id": "Backfill",
            "properties": {
                "approvedBy": {
                    "$ref": "UserTimestamp"
                },
                "backfillId": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "domain": {
                    "type": "string"
                },
                "mandateId": {
                    "description": "Id of the mandate this backfill refers to. If not specified, this backfill\nrefers to default mandate.",
                    "type": "string"
                },
                "outputs": {
                    "description": "Outputs contains all backfill outputs of the given backfill request sorted\nby name.",
                    "items": {
                        "$ref": "BackfillOutput"
                    },
                    "type": "array"
                },
                "proposedBy": {
                    "$ref": "UserTimestamp"
                },
                "version": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "BackfillInfo": {
            "id": "BackfillInfo",
            "properties": {
                "backfillId": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "BackfillOutput": {
            "id": "BackfillOutput",
            "properties": {
                "completionTimestampUs": {
                    "type": "string"
                },
                "end": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "start": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "BackfillResponse": {
            "id": "BackfillResponse",
            "properties": {
                "latestApproved": {
                    "$ref": "Backfill"
                },
                "proposed": {
                    "$ref": "Backfill"
                },
                "status": {
                    "enum": [
                        "ACTIVE",
                        "DISABLED",
                        "PAUSED"
                    ],
                    "enumDescriptions": [
                        "Active backfill will cause unfulfilled instances to get recomputed and also\nto be handled as specified by their 'Valid' and 'Processable' flags. Active\nbackfill can still have some of its outputs paused as specified by the\n'Active' flag of respective outputs.",
                        "Disabled backfill has no affect on computation of pending and completed\ninstances. Disabled backfills are not loaded into graph (RAM).",
                        "Paused backfill will not cause unfulfilled instances to get recomputed, but\nthey would be handled as specified by their 'Valid' and 'Processable'\nflags."
                    ],
                    "type": "string"
                }
            },
            "type": "object"
        },
        "BackfillSummary": {
            "description": "BackfillSummary contains condensed info about a single backfill.",
            "id": "BackfillSummary",
            "properties": {
                "approvedBy": {
                    "$ref": "UserTimestamp",
                    "description": "User who approved the latest version of the backfill."
                },
                "backfillId": {
                    "type": "string"
                },
                "description": {
                    "description": "Description from the proposal of the latest version of the backfill.",
                    "type": "string"
                },
                "domain": {
                    "type": "string"
                },
                "mandateId": {
                    "description": "Id of the mandate this backfill refers to. If not specified, this backfill\nrefers to default mandate.",
                    "type": "string"
                },
                "outputs": {
                    "description": "Output names from the latest version of the backfill.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "proposedBy": {
                    "$ref": "UserTimestamp",
                    "description": "User who proposed the latest version of the backfill."
                },
                "version": {
                    "description": "Id of the latest version of the backfill.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "BorgTaskInfo": {
            "id": "BorgTaskInfo",
            "properties": {
                "cell": {
                    "type": "string"
                },
                "job": {
                    "type": "string"
                },
                "task": {
                    "items": {
                        "format": "int32",
                        "type": "integer"
                    },
                    "type": "array"
                },
                "user": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "BorgTaskLocation": {
            "description": "Information aborg a borg task.\n\nThis can be used to look up the job in sigma/rumbo/herodotus, and may be\nused to find e.g.  task logs, full command lines, information about binary\netc.",
            "id": "BorgTaskLocation",
            "properties": {
                "borgCell": {
                    "type": "string"
                },
                "borgJobCreationTimestampSec": {
                    "description": "The creation timestamp of this borg job. This corresponds to\nBorgJob.created in rumbo, or LookupJob.created for 'borg lookupjob'.",
                    "format": "int64",
                    "type": "string"
                },
                "borgJobName": {
                    "type": "string"
                },
                "borgJobUid": {
                    "description": "The UID of the borg job. Can be used to look up the job on sigma:\nhttp://sigma/global/-/#job?cell=CELL&collection_uid=UID, or borgmaster:\nhttp://master.CELL.borg.google.com/job?uid=UID.",
                    "format": "int64",
                    "type": "string"
                },
                "borgUser": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "ClientReplicaMetadata": {
            "description": "Custom metadata defined by processed logs pipeline that is attached\nto a specific ReplicaGeneration. The metadata should be small, less\nthan 1kb.\nPlease put the extension proto definition under\nlogs/storage/papermill/extensions, and alwayslink to\n\"logs/storage/papermill/extensions\" build target.\nPlease ALWAYS add the extension to the dependency list of\nlogs/storage/papermill/extensions:extensions in order for the extension\nproto to be linked into LogsProtoDB, even if the extension is an existing\nproto that is not under logs/storage/papermill/extensions.",
            "id": "ClientReplicaMetadata",
            "properties": {
                "internalTransactionNumber": {
                    "description": "INTERNAL ONLY.\nTransaction number set by Papermill client library to ensure\nPapermillClient::UpdateMetadata atomicy.",
                    "format": "int64",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "Composite": {
            "description": "The Composite scheduling strategy applies consecutively the inner\nstrategies. Each applied strategy returns a list of instances that are\nconsidered valid given the time_constraint and ordered by the specified\nComputationOrder (from newest to oldest or reversed).\n\nThe order of the inner strategies defines their priority. The list returned\nby strategy N has a higher priority than the one returned by strategy N+1.\n\nThe composite strategy is designed as a more generic solution for defining\nwhat instances should be considered for scheuduling and how they should be\nordered. It supports the definition of multiple time periods where\nseparated groups of computation types should be considered for being\nscheduled.\n\nConsider an example where the desired behaviour is to schedule all first\ncomputation instances from the last 7 days and all recomputation instances\nfrom the last 30 days. Instances from the two time periods can be captured\nindependently by specifying two inner_strategies as follows:\ninner = [\n    (\n       type = [RECOMPUTATION]\n       order = COMPUTE_NEWEST_FIRST\n       time_constraint = {\n         current_time = {}\n         start_offset = -30\n         end_offset = 0\n         period = 'PERIOD_CALENDAR_DAY'\n       }\n    )\n    (\n       type = [FIRST_COMPUTATION]\n       time_constraint = {\n         current_time = {}\n         start_offset = -7\n         end_offset = 0\n         period = 'PERIOD_CALENDAR_DAY'\n       }\n    )\n]\n\nThe ranges defined by the previous two inner_strategies overlap for the\nlast 7 days. For this time period, both inner_strategies will be applied\nin the order of their definition. The first one that matches the instance\nstatus (recomputation/first computation) will used for scheduling the\ninstance.\n\nUltimately, the instances will be scheduled in the following order:\n- all recomputations of the last 30 days from newest to oldest\n- all first computations of the last 7 days from oldest to newest, as this\nis the default order.",
            "id": "Composite",
            "properties": {
                "inner": {
                    "description": "There is a maximum number of 64 InnerStrategies that can be specified.",
                    "items": {
                        "$ref": "InnerStrategy"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "CorpTaskLocation": {
            "description": "Information about a task running in corp.",
            "id": "CorpTaskLocation",
            "properties": {
                "argv": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "hostname": {
                    "type": "string"
                },
                "pid": {
                    "format": "int32",
                    "type": "integer"
                },
                "startTimestampUsec": {
                    "format": "int64",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DebugLocation": {
            "description": "Location of debugging information for this task.",
            "id": "DebugLocation",
            "properties": {
                "cnsFilePattern": {
                    "type": "string"
                },
                "debugString": {
                    "description": "A generic debug string to show verbatim. This may be a long string\n(similar to the status proto), so UIs displaying this must be prepared\nto truncate and expand it if necessary.",
                    "type": "string"
                },
                "description": {
                    "description": "Description of this location (e.g. \"INFO logs for launcher\").",
                    "type": "string"
                },
                "status": {
                    "$ref": "StatusProto"
                },
                "uri": {
                    "description": "The URI needs to start with a http:// or https:// for security, as these\nURIs might be shown in a UI.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DelayedTimestamp": {
            "id": "DelayedTimestamp",
            "properties": {
                "timestamp": {
                    "description": "Timestamp is in seconds since epoch.",
                    "format": "int64",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "Deployment": {
            "description": "All non-deleted deployments of the domain. This includes both the domains\ncoming from user defined mandates and pipeline deployments. The default\nmandate is not included (i.e. there will be no deployments with the\norigin ORIGIN_SYSTEM).",
            "id": "Deployment",
            "properties": {
                "name": {
                    "type": "string"
                },
                "origin": {
                    "enum": [
                        "ORIGIN_UNKNOWN",
                        "ORIGIN_SYSTEM",
                        "ORIGIN_MANDATE",
                        "ORIGIN_PIPELINE_DEPLOYMENT"
                    ],
                    "enumDescriptions": [
                        "",
                        "System mandates are automatically created by Dreampipe. An example would be\nthe default mandate.",
                        "Mandate are created directly by users using the mandate API.",
                        "Deployment mandates are created from user defined pipeline deployments."
                    ],
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DeploymentInfo": {
            "description": "All non-deleted deployments for the requested domain, including both\nuser defined and pipeline deployments. The default deployment is not\nincluded.",
            "id": "DeploymentInfo",
            "properties": {
                "name": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "Domain": {
            "id": "Domain",
            "properties": {
                "outputDomain": {
                    "type": "string"
                },
                "recentHistory": {
                    "items": {
                        "$ref": "NameAndRecentHistory"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "DomainInfo": {
            "description": "Info for one fully specified domain.",
            "id": "DomainInfo",
            "properties": {
                "domain": {
                    "type": "string"
                },
                "outputs": {
                    "items": {
                        "$ref": "OutputInfo"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "DomainWithDefaultMandate": {
            "id": "DomainWithDefaultMandate",
            "properties": {
                "deployments": {
                    "items": {
                        "$ref": "Deployment"
                    },
                    "type": "array"
                },
                "domain": {
                    "description": "The full name of the domain (e.g. mdb/user/subdomain).",
                    "type": "string"
                },
                "preferredMandate": {
                    "description": "For domains with multiple mandates, the preferred one to use.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeAcl..Target": {
            "description": "Target identifies a scope on which an RPC is allowed to be invoked. Some\ntargets may only be defined for certain roles.",
            "id": "DreampipeAcl..Target",
            "properties": {
                "launcherPoolId": {
                    "description": "RPCs targeting this launcher pool are allowed to be invoked.",
                    "type": "string"
                },
                "mandateKey": {
                    "$ref": "DreampipeMandate..MandateKey",
                    "description": "RPCs targeting this mandate are allowed to be invoked. This target can\nonly be defined for ROLE_MANDATE_READER and ROLE_MANDATE_WRITER.\nNOTE: Mandate feature has not yet been launched, this target should not\nbe used."
                }
            },
            "type": "object"
        },
        "DreampipeBackfill..BackfillKey": {
            "description": "BackfillKey uniquely identifies a backfill.",
            "id": "DreampipeBackfill..BackfillKey",
            "properties": {
                "backfillId": {
                    "description": "Unique identifier of a backfill within a domain. This is a timestamp in\nmicroseconds assigned to a backfill by Dreampipe when its first version was\nproposed.",
                    "format": "int64",
                    "type": "string"
                },
                "domain": {
                    "description": "Domain of all outputs contained in the backfill. Backfill can only contain\noutputs from a single domain. This is a fully specified domain, it needs to\ninclude the subdomain as well if it is used. See OutputDef.domain for more\ndetails.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeBackfill..BackfillVersion": {
            "description": "BackfillVersion contains the data pertaining to a single version of a\nbackfill.",
            "id": "DreampipeBackfill..BackfillVersion",
            "properties": {
                "backfillVersionKey": {
                    "$ref": "DreampipeBackfill..BackfillVersionKey",
                    "description": "Unique identifier of the backfill version."
                },
                "createdBy": {
                    "description": "User who created this backfill version. If the version was created using\nthe Dreampipe UI, this is the user who approved it.",
                    "type": "string"
                },
                "description": {
                    "description": "Description of this backfill version.",
                    "type": "string"
                },
                "outputs": {
                    "description": "Outputs contained in the backfill version.",
                    "items": {
                        "$ref": "DreampipeBackfill..Output"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "DreampipeBackfill..BackfillVersionKey": {
            "description": "BackfillVersionKey uniquely identifies a backfill version.",
            "id": "DreampipeBackfill..BackfillVersionKey",
            "properties": {
                "backfillKey": {
                    "$ref": "DreampipeBackfill..BackfillKey",
                    "description": "Unique identifier of a backfill."
                },
                "versionId": {
                    "description": "Unique identifier of a specific backfill version within that backfill. This\nis a timestamp in microseconds assigned to a backfill version when it was\nproposed.",
                    "format": "int64",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeBackfill..InstanceSelector": {
            "description": "Specifies a set of output instances to be included in the backfill based on\ntheir OutputVars values",
            "id": "DreampipeBackfill..InstanceSelector",
            "properties": {
                "dateTimeRange": {
                    "$ref": "DreampipeBackfill.InstanceSelector.DateTimeRange"
                }
            },
            "type": "object"
        },
        "DreampipeBackfill..Output": {
            "description": "Output represents one output included in the backfill.",
            "id": "DreampipeBackfill..Output",
            "properties": {
                "instanceSelector": {
                    "$ref": "DreampipeBackfill..InstanceSelector",
                    "description": "Instances of the output selected for backfil."
                },
                "outputName": {
                    "description": "Name of the Output. Corresponds to OutputDef.name.",
                    "type": "string"
                },
                "processable": {
                    "description": "If processable is set to true, the unfulfilled instances of the output will\nbe used as input for computing dependent instances. Otherwise, the\ncomputation of dependent instances will wait until the instnaces of this\noutput get recomputed.",
                    "type": "boolean"
                },
                "valid": {
                    "description": "If valid is set to true, the unfulfilled instances of the output will be\nincluded in the completed instances query response before they get\nrecomputed. Otherwise, the unfulfilled instances will be considered invalid\nand will not be returned in the completed instances query response before\nthey get recomputed.",
                    "type": "boolean"
                }
            },
            "type": "object"
        },
        "DreampipeBackfill.InstanceSelector.DateTimeRange": {
            "description": "Defines a time interval that applies to OutputVars.date_time. The syntax\nneeds to match the one specified for OutputVars.date_time as defined in\noutput.proto. The timezone is handled the same way as for\nOutputVars.date_time. Start boundary is inclusive, end boundary is\nexclusive.",
            "id": "DreampipeBackfill.InstanceSelector.DateTimeRange",
            "properties": {
                "end": {
                    "type": "string"
                },
                "start": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeDefinition..Acl": {
            "description": "The ACL of an Output.",
            "id": "DreampipeDefinition..Acl",
            "properties": {
                "instanceReader": {
                    "description": "List of prod groups or users allowed to read output instances.\nRequired for QueryPendingInstances RPCs.\n\nNote: this group only affects the visibility of the output instance\nmetadata in Dreampipe and offers no protection for the actual output\nfiles. You'll need to set output file ACLs accordingly.\n\nNote that instance_writer and owner automatically have this access\nas well.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "instanceWriter": {
                    "description": "List of prod groups or users allowed to write new output instances.\nRequired for AcquireLock and CompleteInstances RPCs. This automatically\nimplies instance_reader access as well.\n\nNote that owner automatically has this access as well.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "outputDefReader": {
                    "description": "Note: The owner of the output is not part of the Acl, as it is implicitly\ndefined as the first part of the Output.name (as the first path component).\nOwner access is required for InsertOrUpdateOutput RPC.\n\nList of prod groups or users allowed to read the OutputDef.\nRequired for QueryOutputs and LookupOutputs RPCs. Example: \"mdb/your-team\".\n\nNote that instance_reader, instance_writer and owner automatically have\nthis access as well.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "DreampipeDefinition..Creator": {
            "description": "Information about user/role who created the OutputDef.",
            "id": "DreampipeDefinition..Creator",
            "properties": {
                "userId": {
                    "description": "Role/User id without mdb/usr prefix.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeDefinition..DefinitionSource": {
            "description": "Because Dreampipe signals are added using RPC calls, tracing their\nsource can be hard. This message allows adding breadcrumbs that make this\neasier. This message is not used by Dreampipe.",
            "id": "DreampipeDefinition..DefinitionSource",
            "properties": {
                "document": {
                    "description": "Any supporting material (design docs) pertaining to this definition.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "mpmSpec": {
                    "$ref": "DreampipeDefinition..MpmSpec",
                    "description": "The MPM which contains the OutputDef that was used in the push\n(e.g. as a dar archive). Typically populated by dreampipe-push tool."
                },
                "piperCl": {
                    "description": "The CL number where this OutputDef was added.",
                    "format": "int64",
                    "type": "string"
                },
                "piperPath": {
                    "description": "The source file location where the Output was defined. Use piper paths,\nin the format //depot/google3/path/to/file.dream.",
                    "type": "string"
                },
                "sourceLine": {
                    "description": "The source line number location within piper_path which best corresponds\nto the start of the definition of the Output (one-indexed).\nOptional: you can use this if piper_path is likely to contain many\ndefinitions.",
                    "format": "int32",
                    "type": "integer"
                }
            },
            "type": "object"
        },
        "DreampipeDefinition..InputDef": {
            "description": "The InputDef defines an input needed to produce an output. The InputDef\ndepends on instance parameters of the corresponding output (e.g. date for\nperiodic outputs).",
            "id": "DreampipeDefinition..InputDef",
            "properties": {
                "acceptedFormats": {
                    "description": "If an input is available in multiple formats (e.g. SawmillLog may be\navailable as recordio and columnio), which formats are accepted.\n\nThe possible values depend on the input type. If empty, an input-specific\ndefault is chosen.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "bunyan": {
                    "$ref": "DreampipeDefinition.InputDef.Bunyan"
                },
                "custom": {
                    "$ref": "DreampipeDefinition.InputDef.Custom"
                },
                "dreampipe": {
                    "$ref": "DreampipeDefinition.InputDef.Dreampipe"
                },
                "file": {
                    "$ref": "DreampipeDefinition.InputDef.File"
                },
                "inputRange": {
                    "$ref": "DreampipeDefinition.InputDef.InputRange"
                },
                "inputsRequired": {
                    "$ref": "DreampipeDefinition.InputDef.RequiredInputs",
                    "description": "If set, specifies how many instances are required for this input.\nUse this when:\n * you know ahead of time how many inputs you are expecting to appear\n   in the range, or\n * there may be more inputs, but you only care about this many of them."
                },
                "instanceVersionThrottler": {
                    "$ref": "DreampipeDefinition.InputDef.InstanceVersionThrottler",
                    "description": "InstanceVersionThrottler defines times when the latest version of the input\nshould be chosen to trigger a first computation or recomputation.\nTherefore, when this is specified, it will throttle computations that use\nany other input version but the one closest to the defined points in time.\nIf there is no version available at the first defined point in time,\nDreampipe will wait for a first version to appear and schedule a first\ncomputation afterwards. Therefore, the first defined point in time (let's\ncall it T1) should not be regarded as a strict cutoff date. There might be\ncases when the first computation uses an input instance version that is\nolder than T1.\n\nFor the next points in time after T1, Dreampipe will choose the latest\navailable version that is dated before the timestamp and compare it to the\npreviously used one to detect whether a change happened (aka new versions\nappeared). Note that you must use RECOMPUTE_ON_UPDATE if the\nInstanceVersionThrottler defines more than a single point in time.\n\nFor inputs of type File whose path contains the {version} variable,\nDreampipe does not track a timestamp of the file and hence cannot know when\nthe version appeared. Therefore, in this case, for every time point defined\nby the InstanceVersionThrottler, it will be considered that the file has\nchanged and thus it will trigger a computation no matter what.\n\n----------------------\nThe following are several examples of how the InstanceVersionThrottler can\nbe specified:\n\n// Case I - run only once, 4 hours after the end of the input instantiation\nday:\n instance_version_throttler = {\n  computation_schedule = {\n    enumerated = [\n     { days = 1, seconds = 4 * 3600 },\n    ]\n  }\n }\n\n// Case II - run intra-day every hour, but only until 4 hours after the end\nof the logging day:\n instance_version_throttler = {\n   computation_schedule = {\n     periodic = [\n       {\n         start = { seconds = 3600 },\n         period = 3600\n         period_unit = 'PERIOD_SECOND'\n         end = { days = 1, seconds = 4 * 3600 + 1 },\n       }\n     ]\n   }\n##  }\n\nWhen no InstanceVersionThrottler is specified, Dreampipe will default to\nscheduling the re/computations as soon as any input version becomes\navailable."
                },
                "name": {
                    "description": "The name that gets passed to the launcher as an identifier for this input.\nThis name needs to be unique within the OutputDef object. However, it is\npossible to re-use the name across OutputDefs, and in fact this can be\nuseful to avoid duplicating query.InputRequirement protos.\n\nNote that this name identifies the input for all time, i.e. also for\ncomputations that have happened earlier, *and* to determine if the inputs\nof those computations have changed in a way that triggers recomputation.",
                    "type": "string"
                },
                "numInputsOptional": {
                    "description": "If set, specifies how many of the instances can be missing from this\ninput. This is a number between 0 and the expected_max, which in turn\nis defined as follows:\n\n * for inputs with a pre-defined periodicity (e.g. Bunyan, Sawmill,\n   Dreampipe), expected_max is defined as the number of inputs that\n   belong to the start/end range; or\n * for the deprecated offset + period mechanism, expected_max is\n   len(offset).\n\nThis field can't be used with inputs where Dreampipe can't deduce a\npriori how many instances there can be.",
                    "format": "int32",
                    "type": "integer"
                },
                "offset": {
                    "description": "Deprecated.\n\nThe list of offsets for periodic inputs. An offset defines a dated\ninput instance relative to the date/time of the output instance.\nSee \"periodicity\" below for how this works.\n\nThis field is repeated; this is a shortcut for specifying multiple\ninputs that only differ on the output.\n\nNegative numbers go back in time. For example, [-1, 0] means that\nthe computation depends on dates from yesterday and today (in relation\nto the date of the output), assuming that the period = 1 calendar day.\n\nThe offsets are in terms of the periodicity given here. For example,\nto depend on 3 past hours, use\n\n periodicity = SECOND\n offset = [-7200, -3600, 0]\n\nIf not specified, [0] is assumed for inputs that support dates.\n\nThis field is deprecated in favor of more flexible input ranges.",
                    "items": {
                        "format": "int32",
                        "type": "integer"
                    },
                    "type": "array"
                },
                "period": {
                    "description": "Deprecated.\n\nThe periodicity, used as unit for offsets.\n\nNote that periods of PERIOD_CALENDAR_DAY and PERIOD_CALENDAR_MONTH work\nin terms of calendar dates. For example, if OutputDef B depends on\ncomputations produced by OutputDef A, and both of them have daily\nperiodicity in different timezones, the instantiation happens at the time\nof start_date_time on their respective timezone. However, dependency\nacross the outputs works based on the date regardless of the exact time\nwhen their instantiation happens.\n\nWhen the InputDef.period is PERIOD_SECOND, the dependency is based on\nabsolute timestamps instead, i.e. they have to match to the second.\n\nThis field is deprecated in favor of more flexible input ranges.",
                    "enum": [
                        "PERIOD_UNKNOWN",
                        "PERIOD_SECOND",
                        "PERIOD_CALENDAR_DAY",
                        "PERIOD_CALENDAR_MONTH"
                    ],
                    "enumDescriptions": [
                        "Not to be used. See go/protodosdonts.",
                        "Second as defined by SI.",
                        "Day defines a calendar day periodicity. Most days are 24 hours long,\nbut around daylight savings times they may be 23 or 25 hours.",
                        "Calendar month periodicity."
                    ],
                    "type": "string"
                },
                "recomputationPolicy": {
                    "description": "recomputation_policy defines what should be considered a recomputation\ntrigger when two versions of this input are compared.\nIf multiple values are enumerated here,  one of them needs to be fulfilled\nin order to consider an output to be eligible for recomputation.\nLet's consider the following example:\nrecomputation_policy = {RECOMPUTE_ON_DELETION, RECOMPUTE_ON_UPDATE}\nIn this case, Dreampipe will schedule a recomputation of the corresponding\noutput in case the latest version of this input was either deleted OR\nchanged.\n\nFor backwards compatibility, no value set for the recomputation_policy will\ndefault to trigger recomputations on input versions added or changed.\n\nNote: Recomputations might be throttled by the scheduling strategy defined\nat the QPI level. An output instance will be scheduled for recomputation if\nit is enabled both by the scheduling_strategy and the recomputation_policy.",
                    "enumDescriptions": [
                        "Default case, not to be used. See go/protodosdonts.",
                        "Recomputation is never triggered. This option should not be combined\nwith any other enum values.",
                        "Recomputation is triggered when any of the input instances that were\npreviously used to compute an output are modified. For example, if an\noutput was produced using an instance of a table, it will only be\nrecomputed when a new version of the same instance of the same table\nappears.\n\nNote: Dreampipe does not recompute when any input instance is changed to\nan older version. For example, let's assume that there's an input\ninstance with two versions v1 and v2 simultaneously available. When an\noutput instance is first computed from this input, then the latest\nversion (let's say v2) is chosen. If v2 later becomes unavailable, then\nv1 would be the only available version of this input. However, since v1 <\nv2, this would not be considered a change and hence it will not trigger\na recomputation.",
                        "This option is deprecated. Use RECOMPUTE_ON_UPDATE instead.",
                        "Recomputation is triggered when a new input instance is added into the\nInputRange defined by the input. For example, let's consider a daily\noutput that depends on hourly instantiated inputs. The output is produced\nusing all input instances of the instance date and it requires at least\none to be available in order to compute. Let's consider the following\ntimeline of a day:\n  * at 00:00:00 an input instance is produced. It triggers the\ncorresponding output to be produced as well.\n  * at 01:00:00 a new input instance is produced. Today's output will be\nrecomputed using both available inputs: 00:00 and 01:00.\n  * for each of the following hours of the day a new input instance\nshould be computed. Once any of them is available, it will trigger a\nrecomputation of the output.\n\nNote: ADDITION does not refer to adding new InputDefs, but to the\naddition of new input instances of the same InputDef. Setting this option\nmakes sense when the output is defined to be produced from a range of\ninstances of the same input.",
                        "Recomputation is triggered when an input instance, that belongs to the\nInputRange defined by the input, is deleted.\nThis option does not override the InputDef.input_constraint field.\nWhen input instances are deleted, the recomputation is NOT triggered if\nthe number of the remaining instances is less than the minimum required\nby num_required or num_inputs_optional fields.\n\nNote: DELETION does not refer to deleting InputDefs, but to the deletion\nof existing input instances. Setting this option makes sense when the\noutput is defined to be produced from a range of instances of the same\ninput."
                    ],
                    "items": {
                        "enum": [
                            "RECOMPUTE_UNSPECIFIED",
                            "RECOMPUTE_NONE",
                            "RECOMPUTE_ON_UPDATE",
                            "RECOMPUTE_ON_CHANGE",
                            "RECOMPUTE_ON_ADDITION",
                            "RECOMPUTE_ON_DELETION"
                        ],
                        "type": "string"
                    },
                    "type": "array"
                },
                "sawmillLog": {
                    "$ref": "DreampipeDefinitionSawmill..SawmillLog"
                },
                "versionFeatureComparator": {
                    "description": "version_feature_comparator is an INT64 GoogleSQL expression that controls\nhow two instances (exiting and recomputation candidate) of the\nversion_feature_extractor output are compared.\n\nThe schema of the input row is as follows (with T being the output type of\nthe version_feature_extractor expression):\nSTRUCT<T candidate, T existing>.\n\nIt should return 0 if two candidate features are considered same,\nthus signalling that a recomputation should not be triggered, <0 if\ncandidate version should be considered older than the existing version\nand >0 if the candidate version should be considered newer than the\nexisting version.\n\nIf this field is not specified, string comparison between VersionFeatures\nis used, and any difference is considered as if the candidate is newer\nthan existing.\n\nNote that, when computing the version features for the new candidate\ninput version (to be passed to the comparator),\nthe version_feature_extractor corresponding to the OutputDef that was used\nto compute the existing version is used. This ensures that the schema\nof the existing VersionFeatures is the same as those computed for the\ncandidate, and it avoids spurious recomputations every time the definition\nof the version_feature_extractor is updated.\nThis is in line with the general Dreampipe behavior of only triggering\nupdates if the inputs used to compute a particular output instance have\nchanged (but avoid triggering updates if a new input has been added).",
                    "type": "string"
                },
                "versionFeatureExtractor": {
                    "description": "version_feature_extractor is a GoogleSQL expression that\noperates on a single row of the VersionMetadata proto and\nreturns a value that contains relevant features of the version described by\nthe input VersionMetadata proto for the purposes of recomputation\nscheduling.\n\nThe output of this expression for a computed instance will be stored in\nDreampipe, and will be compared to the output for a new candidate\ncomputation to decide whether to schedule a recomputation.\n\nAllowed output types of this expression are GoogleSQL primitive types and\nstructs and arrays of primitive types (recursively, so structs of structs\nare also supported). However, be careful when using numbers with floating\npoint precision, especially when doing equality comparison.",
                    "type": "string"
                },
                "versionPredicate": {
                    "description": "version_predicate is a boolean GoogleSQL expression that\noperates on a single row of the dreampipe.ephemeral.VersionMetadata proto\n(google3/pipeline/dreampipe/public/proto/metadata_for_version_selection.proto)\nand returns TRUE if the metadata proto represents an input version\nthat the user wants to consume, and FALSE otherwise.\n\nIf the predicate returns TRUE for multiple simultaneously\navailable versions, the latest version will be returned.\nTo give preference to certain versions, use the fact that\nthe order of the predicates matters, the first predicate will\nbe executed against all versions, and only if it returns FALSE\nfor all versions Dreampipe will continue to the next predicate.\n\nFor sawmill inputs, if none of (version_predicate,\nversion_feature_extractor, version_feature_comparator) are set, the default\nbehavior is to accept materialized or explicit join (e.g.\nAdEvents+ConvStats) versions.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "DreampipeDefinition..Instantiation": {
            "description": "The instantiation schedule of an Output.\n\nTwo things need to be satisfied before an Output instance can be scheduled\n(in other words, returned for a QueryPendingInstances query):\n\n * the instantiation time for that output instance, as defined by this\n   Instantiation proto, must have passed; and\n * all (or enough) input dependencies must be available, as specified by the\n   InputDef proto.\n\nNote that after these two things are satisfied, it only means that the\noutput instance can be scheduled for computing. The instance is actually\nonly created after it has been successfully computed (or, more accurately,\nafter the CompleteInstances call has been completed).",
            "id": "DreampipeDefinition..Instantiation",
            "properties": {
                "periodic": {
                    "$ref": "DreampipeDefinition.Instantiation.Periodic"
                }
            },
            "type": "object"
        },
        "DreampipeDefinition..MpmSpec": {
            "id": "DreampipeDefinition..MpmSpec",
            "properties": {
                "name": {
                    "description": "Path of the MPM",
                    "type": "string"
                },
                "versionId": {
                    "description": "The full version id of the MPM",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeDefinition..OutputDef": {
            "description": "The OutputDef is a definition of an output produced by a computation.\nOutputDef is the main unit of instantiation.\n\nNote that each Output should represent one logical type of computation.\nIf a single computation produces two unrelated outputs as a byproduct, these\nshould be expressed as two outputs which simply get chosen for execution\nby a launcher at the same time.",
            "id": "DreampipeDefinition..OutputDef",
            "properties": {
                "acl": {
                    "$ref": "DreampipeDefinition..Acl",
                    "description": "The ACL defines who can access the Dreampipe metadata for this OutputDef\nand its instances. If no acl is specified, we use the prod group or user\nfrom the OutputDef.domain (see above)."
                },
                "createdBy": {
                    "$ref": "DreampipeDefinition..Creator",
                    "description": "Logical user assumed by the peer who executed the stubby that created this\noutput_def. If the peer was a proxy, this is the role of the client\nusing the proxy, not the proxy itself.\n\nThis field should be left empty when adding the definition: it is\nautomatically determined by Dreampipe."
                },
                "definitionSource": {
                    "$ref": "DreampipeDefinition..DefinitionSource",
                    "description": "This field is not used by Dreampipe scheduler directly. It provides\ndocumentation and traceability; also, Dreampipe launchers may use it when\nstarting new jobs."
                },
                "domain": {
                    "description": "The domain of the OutputDef. By convention, this is the owner of the\nOutputDef (either prod group or user).\n\nExample: \"mdb/prod-group\", owner=\"mdb/prod-group\"\nExample: \"user/prod-user\", owner=\"user/prod-user\"\n\nIn addition, you may create subdomains within your domain to allow for\nmore fine-grained grouping of computations. The subdomain follows the\nowner, separated by '/'.\n\nExample: \"mdb/prod-group/subdomain\", owner=\"mdb/prod-group\",\n    subdomain=\"subdomain\".\nExample: \"user/prod-user/sub/domain\", owner=\"user/prod-user\",\n    subdomain=\"sub/domain\".\n\nNote that the prod group or user defines the owner for various purposes:\n - in the absence of an acl, it sets the default ACL\n - only a member of the prod group (nee mdb group) can add the definition.",
                    "type": "string"
                },
                "input": {
                    "description": "The list of Inputs to this OutputDef.",
                    "items": {
                        "$ref": "DreampipeDefinition..InputDef"
                    },
                    "type": "array"
                },
                "instantiation": {
                    "$ref": "DreampipeDefinition..Instantiation",
                    "description": "Control how this output should be instantiated from this OutputDef."
                },
                "name": {
                    "description": "The name of the OutputDef. The name needs to be unique in the domain.",
                    "type": "string"
                },
                "output": {
                    "description": "The list of output locations where this output is stored. Note that\neach OutputDef should define a single logical output; therefore, these\nshould either be identical data in different formats or locations, or\nat least very closely associated files (such as a file and its associated\nindex).\n\nLet's consider two Dreampipe outputs O1 and O2, where O2 uses O1 as input:\n\n  * If the output of O1 is replicated to multiple clusters and O2 reads\nonly a subset of them, then this must be set in the cluster_locality field:\nhttp://cs/?q=symbol:dreampipe.scheduling.InputRequirement.cluster_locality\n\n  * If the output of O1 is stored in the same location path, but in\ndifferent formats (OutputLocation.location.file.format) and O2 reads only a\nsubset of them, then this must be set in the accepted_formats field:\nhttp://cs/?q=symbol:dreampipe.definition.InputDef.accepted_formats",
                    "items": {
                        "$ref": "DreampipeDefinition..OutputLocation"
                    },
                    "type": "array"
                },
                "tag": {
                    "description": "Tag is an arbitrary identifier that can be used to group related outputs\ntogether. In particular, the scheduling query may refer to a tag.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "timestamp": {
                    "description": "The timestamp of this OutputDef. The timestamp identifies the version\nof the OutputDef. The most recent OutputDef is used for computations,\nbut past versions are retained for dependency tracking purposes.\n\nThis field should be left empty when adding the definition: it is\nautomatically determined by Dreampipe when the OutputDef is written into\nDreampipe metadata store.\nUnit: microseconds.",
                    "format": "int64",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeDefinition..OutputLocation": {
            "description": "The OutputLocation defines a particular location for an Output.\nYou can omit location if your computation does not create any files.",
            "id": "DreampipeDefinition..OutputLocation",
            "properties": {
                "file": {
                    "$ref": "DreampipeDefinition.OutputLocation.File"
                },
                "name": {
                    "description": "The name that gets passed to the launcher as an identifier for this output.\nThis is optional and does not need to be unique.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeDefinition.InputDef.Bunyan": {
            "id": "DreampipeDefinition.InputDef.Bunyan",
            "properties": {
                "instance": {
                    "description": "The Bunyan instance, identified by the location of the Bunyan metadata\nbigtable. You should use a canonical location, preferring gslb if one\nexists. E.g. \"gslb:adspam-bunyan_main_prod\".\n\nNote that in order to be able to use Bunyan outputs as inputs, the\nBunyan metadata service, which runs under 'mdb.adspam-bunyan', needs\nread access to your metadata bigtable.",
                    "type": "string"
                },
                "signalName": {
                    "description": "The name of the signal (a materialized view) in Bunyan.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeDefinition.InputDef.Custom": {
            "description": "Use the Custom input type to create inputs which are tracked using custom\nlogic using the remote input watcher protocol. Please read\nSee http://g3doc/pipeline/dreampipe/g3doc/input_watcher before using\nthis protocol.",
            "id": "DreampipeDefinition.InputDef.Custom",
            "properties": {
                "name": {
                    "description": "A name identifying the input source to be watched. Note the guidance\nin http://g3doc/pipeline/dreampipe/g3doc/input_watcher suggesting that\nthis field shouldn't be used to modify run-time parameters of the remote\ninput watcher.",
                    "type": "string"
                },
                "watcherDomain": {
                    "description": "The prod group which is responsible for watching this input. You need\nto set this field always for custom input watchers, because Dreampipe's\ndefault watchers won't know about your custom inputs. Format:\nmdb/<prod-group-name>.\n\nFor more information about remote input watchers, see\nhttp://g3doc/pipeline/dreampipe/g3doc/input_watcher.md.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeDefinition.InputDef.Dreampipe": {
            "id": "DreampipeDefinition.InputDef.Dreampipe",
            "properties": {
                "mandateId": {
                    "description": "If set, only the instance versions fulfilling the given mandate\nwill be considered.\nIf not set then:\n  - within the same domain, the instance versions have to fulfill same\n    mandate as the output.\n  - for inputs from another domain we will use \"default\" mandate (i.e.\n    the latest version of the instance, ignoring the mandates if any).\n    Notice, that if the source domain uses mandates, you very likely\n    want to populate this field.",
                    "type": "string"
                },
                "outputDomain": {
                    "description": "Output from another Dreampipe computation. This refers to another\noutput with matching OutputDef.domain and OutputDef.name.",
                    "type": "string"
                },
                "outputName": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeDefinition.InputDef.Endpoint": {
            "description": "Endpoint defines either the start or end point of a date or datetime\nrange which will be considered for updates. The endpoint is defined\nas:\n\n  reference_time + offset_months + offset_days + offset_seconds",
            "id": "DreampipeDefinition.InputDef.Endpoint",
            "properties": {
                "currentTime": {
                    "$ref": "DreampipeTime..CurrentTime"
                },
                "excludeEndpoint": {
                    "description": "By default, both endpoints are included in the range.",
                    "type": "boolean"
                },
                "fixedDateTime": {
                    "$ref": "DreampipeTime..FixedDateTime"
                },
                "instanceTime": {
                    "$ref": "DreampipeTime..InstanceTime"
                },
                "offsetDays": {
                    "format": "int32",
                    "type": "integer"
                },
                "offsetMonths": {
                    "description": "The offset from reference_time. The offsets are computed using calendar\nunits (months and days) in the timezone of the Output.",
                    "format": "int32",
                    "type": "integer"
                },
                "offsetSeconds": {
                    "format": "int32",
                    "type": "integer"
                }
            },
            "type": "object"
        },
        "DreampipeDefinition.InputDef.File": {
            "id": "DreampipeDefinition.InputDef.File",
            "properties": {
                "candidateLocation": {
                    "description": "List all possible locations where this input may be stored. These should\nbe considered interchangeable locations of the same logical input, i.e.\nthese should be replicas of the same file.\nYou may also consider using http://go/placer for replication.\n\nNote that Dreampipe doesn't read the files, so it can't know when two\nfiles have the same content. Therefore it by default assumes that\nwhenever a new file becomes available, the input has been updated, and\nit creates a new version of the input, potentially triggering\nrecomputations.\n\nIf you want to avoid recomputations, you should explicitly specify the\nversion in your path, and capture it using the {version} variables.\nSee http://g3doc/pipeline/dreampipe/g3doc/variables#version for more\ninformation about capturing the version variable.\n\nNOTE: By default, Dreampipe needs access to stat the files. Please see\nhttp://g3doc/pipeline/dreampipe/g3doc/input_watcher for more information,\nincluding the minimum required permissions on the files and directories.",
                    "items": {
                        "$ref": "DreampipeDefinition.InputDefFile.Location"
                    },
                    "type": "array"
                },
                "variableTimezone": {
                    "description": "Timezone for any date or time variables used in the Location.pattern,\nusing the IANA tz database identifiers. If not specified,\nAmerica/Los_Angeles is assumed by default.",
                    "type": "string"
                },
                "watcherDomain": {
                    "description": "The prod group which is responsible for watching this input. In the usual\ncase, this field should be left empty, which signals that Dreampipe's\nbuilt-in input watchers should track this input. However, in some\ncases it is advantageous to delegate watcher to dedicated remote input\nwatchers. Format: mdb/<prod-group-name>.\n\nFor more information about remote input watchers, see\nhttp://g3doc/pipeline/dreampipe/g3doc/input_watcher.md.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeDefinition.InputDef.InputRange": {
            "description": "The range start..end defines which instances are considered in this range.\nAll instances whose instance dates or datetimes are in the range between\nstart and end are returned, in other words, if input_ts is the datetime of\nthe input instance, it needs to be in the range:\n\n  start <= input_ts <= end.\n\nYou can control if the endpoint itself is included in the range with\nexclude_endpoint; half-closed ranges are usually best for uniform\ncoverage.\n\nAll inputs and outputs dates and datetimes always have a timezone. However,\nthe comparison always happens as timestamps. If you have e.g. daily inputs\nand outputs, but input defined in different timezone from output, you'll\nneed to add enough buffer to make sure the range covers the intended range.\nExtra care around DST changes is required, as they happen on different\ndates and times depending on the timezone.\n\nExample: output follows input datetimes exactly:\n\nstart = { }\n  end = { }\n\n(This is the default setup. If start and end are not defined, you'll get\nthis identity dependency automatically.)\n\nExample: use last 7 days of input, input and output timezones match:\n\n start = { offset_days = -7, exclude_endpoint = true }\n   end = { offset_days = 0 }",
            "id": "DreampipeDefinition.InputDef.InputRange",
            "properties": {
                "end": {
                    "$ref": "DreampipeDefinition.InputDef.Endpoint"
                },
                "start": {
                    "$ref": "DreampipeDefinition.InputDef.Endpoint"
                }
            },
            "type": "object"
        },
        "DreampipeDefinition.InputDef.InstanceVersionThrottler": {
            "id": "DreampipeDefinition.InputDef.InstanceVersionThrottler",
            "properties": {
                "computationSchedule": {
                    "$ref": "DreampipeTime..TimeSchedule",
                    "description": "The computation_schedule defines a timetable when the latest version of\nthe input instance should be used to produce or update an output.\n\nThe timetable is a set of periodic dates and points in time that are\nrelative to the instantiation time of the input instance. Dreampipe will\nwait each of those times to pass and schedule a computation afterwards."
                }
            },
            "type": "object"
        },
        "DreampipeDefinition.InputDef.RequiredInputs": {
            "description": "RequiredInputs provides a way of setting input_constraint when we know\nhow many inputs to expect.",
            "id": "DreampipeDefinition.InputDef.RequiredInputs",
            "properties": {
                "inputSelector": {
                    "enum": [
                        "INPUTS_RETURNED_UNKNOWN",
                        "RETURN_ALL_INPUTS",
                        "RETURN_FIRST_N_INPUTS",
                        "RETURN_LAST_N_INPUTS"
                    ],
                    "enumDescriptions": [
                        "Not to be used. See go/protodosdonts.",
                        "Returns all available inputs.",
                        "First num_required inputs are returned. For dated inputs,\nfirst means earliest in time.",
                        "Last num_required inputs are returned. For dated inputs,\nlast means latest in time."
                    ],
                    "type": "string"
                },
                "numRequired": {
                    "format": "int32",
                    "type": "integer"
                }
            },
            "type": "object"
        },
        "DreampipeDefinition.InputDefFile.Location": {
            "id": "DreampipeDefinition.InputDefFile.Location",
            "properties": {
                "doneFilePattern": {
                    "description": "Optional pattern for a done file. If non-empty, this determines when\nthe location is valid. Note that in this case, the existence of\npattern is not checked at all.)\n\nVariables captured in the done_file_pattern may be used in pattern.\n\nIf your done file follows the convention that it encodes the number of\nshards, you can capture it with the special variable {num_shards}.\n\nNOTE: Dreampipe by default needs stat access to the files. See\ncandidate_location below.",
                    "type": "string"
                },
                "pattern": {
                    "description": "A google3 File API filename pattern. Can e.g. be a file stored on CNS\nor placer. Can contain any file type (sstable, recordio, columnio ...).\nPattern may contain variables in the Dreampipe variable format:\nhttp://g3doc/pipeline/dreampipe/g3doc/variables.md.\n\nSharded files are supported using the basename@10 notation. If the\nnumber of shards is not known, you can use basename@*. If your done\nfile follows the convention that it encodes the number of shards (see\nbelow), you can use basename@{num_shards}.\n\nNote that a sharded file only matches if all shards are present.\nYou may also matching using globs, e.g. \"-?????-of-?????\", but these\nwill also match partial results. Note that even if all shards are\npresent, they may still be incomplete; please use done files or\natomic filesystems such as placer to avoid partial inputs.\n\nNOTE: Dreampipe by default needs stat access to the files. See\ncandidate_location below.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeDefinition.Instantiation.Periodic": {
            "id": "DreampipeDefinition.Instantiation.Periodic",
            "properties": {
                "deleteAfterDays": {
                    "description": "Deprecated. Push a retention policy instead.\nSee http://go/dreampipe-deleter-faq for more information.\n\nFor periodic outputs, delete_after_days defines the nominal lifetime\nof the instance. The date is defined from the instantiation date of the\noutput instance.\nNote in particular that deletion does not depend on the latest\ncomputation time. If the data is from 2014-01-01 with delete_after=365.0\nand latest computation is 2014-12-31, it will still be eligible for\ndeletion on 2015-01-01.\n\nNote that the instance is not deleted or forgotten automatically after\nthis time is up; instead, it is marked as being available for deletion\nby a dedicated deleter job.\n\nAn output instance that has exceeded its delete_after should not be used\nas a dependency for other computations.\n\nIt is the responsibility of the deleter job to delete the output files\nbefore deleting the output instance.",
                    "format": "double",
                    "type": "number"
                },
                "endDateTime": {
                    "description": "End_date defines the date from which Dreampipe will stop scheduling\nthe outputs. This is exclusive. If unset, Dreampipe will keep scheduling\nthe output indefinitely.",
                    "type": "string"
                },
                "instantiationOffset": {
                    "$ref": "DreampipeDefinition.InstantiationPeriodic.InstantiationOffset",
                    "description": "Instantiation offset allows to either delay the instantiation of an\noutput by (# calendar_days, # seconds) from the start_date_time, or\nadvance the instantiation of an output by (# calendar_days, # seconds)\nwhen the offsets are negative."
                },
                "multiplier": {
                    "format": "int32",
                    "type": "integer"
                },
                "periodicity": {
                    "description": "The period, defined as: period = Periodicity * multiplier.\n\nWe support three units (seconds, days and months); the latter two are\ncalendar units (i.e. some days are 25 or 23 hours long around DST\nchanges).\n\nThe signal repetition is always defined by keeping start_date_time as\nthe reference. For example, to choose weekly executions at 3am on\nMondays starting from 2014-11, specify:\n\n start_date_time = 2014-11-03\n periodicity = PERIOD_CALENDAR_DAY\n multiplier = 7\n offset.seconds = 10800\n\nIf periodicity is not set, we assume PERIOD_CALENDAR_DAY by default.\nIf multiplier is not set, we assume 1 by default.\n\nLogically, the output instance becomes schedulable exactly at the time\nof the period; for PERIOD_CALENDAR_DAY or higher, it's 0:00:00 of the\ndate in the timezone in question, unless an offset is specified. However,\nfor dependencies to other outputs, periodicity for calendar periods is\ndifferent than for PERIOD_SECOND periods (see InputDef.period).",
                    "enum": [
                        "PERIOD_UNKNOWN",
                        "PERIOD_SECOND",
                        "PERIOD_CALENDAR_DAY",
                        "PERIOD_CALENDAR_MONTH"
                    ],
                    "enumDescriptions": [
                        "Not to be used. See go/protodosdonts.",
                        "Second as defined by SI.",
                        "Day defines a calendar day periodicity. Most days are 24 hours long,\nbut around daylight savings times they may be 23 or 25 hours.",
                        "Calendar month periodicity."
                    ],
                    "type": "string"
                },
                "startDateTime": {
                    "description": "Start_date defines the date from which Dreampipe will schedule\nthe outputs. Without any limit, Dreampipe would be required to\nschedule outputs indefinitely back in time; therefore, this is a\nrequired value.\n\nNote that if delete_after_days is set, the effective instantiation date\nis the latter of start_date, (now - delete_after_days).\nSyntax is a subset of ISO8601: 2014-11-13, without a time\ncomponent (despite what it says in the field name).",
                    "type": "string"
                },
                "timezone": {
                    "description": "Timezone for the start_date_time and end_date_time, using the IANA tz\ndatabase identifiers. If empty, the default value of America/Los_Angeles\nis used instead.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeDefinition.InstantiationPeriodic.InstantiationOffset": {
            "id": "DreampipeDefinition.InstantiationPeriodic.InstantiationOffset",
            "properties": {
                "calendarDays": {
                    "description": "Instantiation time happens at nominal instance_time + calendar_days +\nseconds. The offsets can be positive or negative.",
                    "format": "int32",
                    "type": "integer"
                },
                "seconds": {
                    "format": "int32",
                    "type": "integer"
                }
            },
            "type": "object"
        },
        "DreampipeDefinition.OutputLocation.File": {
            "id": "DreampipeDefinition.OutputLocation.File",
            "properties": {
                "format": {
                    "description": "The format of this output (e.g. recordio, columnio).",
                    "type": "string"
                },
                "location": {
                    "description": "Location is the path pattern that may contain variables in the Dreampipe\nvariable format: http://g3doc/pipeline/dreampipe/g3doc/variables.md.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeDefinitionSawmill..LogSelector": {
            "description": "Sawmill logs may change over time; LogSelector chooses which versions\nof the log are considered. This applies both to first versions and to\nupdates of the log.",
            "id": "DreampipeDefinitionSawmill..LogSelector",
            "properties": {
                "timeSchedule": {
                    "$ref": "DreampipeTime..TimeSchedule",
                    "description": "The time_schedule throttles the log updates by time, relative to the\nstart of the logging day.\n\nThe LogSelector is used to specify points in time, relative to the nominal\ninstance date of the input. Dreampipe will wait at least until [1] each\nof these timepoints before actually scheduling the computation (either\nfirst computation or a recomputation).\n\nExamples (using GCL syntax):\n\n // Run only once, 4 hours after the end of the logging day (or when the\n // log first appears, whichever is later).\n time_schedule = {\n   enumerated = [\n     { days = 1, seconds = 4 * 3600 },\n   ]\n }\n\n // Run for the first time at or after 3 hours after the end of the\n // logging day, and then once a day as long as the log keeps changing.\n time_schedule = {\n   periodic = [\n     {\n       start = { days = 1, seconds = 3 * 3600 },\n       period = 1\n       period_unit = 'PERIOD_CALENDAR_DAY'\n     }\n   ]\n }\n\n // Run intra-day every hour, but only until 4 hours after the end of\n // the logging day.\n time_schedule = {\n   periodic = [\n     {\n       start = { seconds = 3600 },\n       period = 3600\n       period_unit = 'PERIOD_SECOND'\n       end = { days = 1, seconds = 4 * 3600 + 1 },\n     }\n   ]\n }\n\nNote that the logs are updated differently depending on their flavor:\n\n * collected logs and continuous processed logs are updated continuously,\n   only to stop some time after the end of the logging day;\n * processed logs created with a batched process appear at discrete time\n   intervals usually after the end of the logging day.\n\nNote that update processes such as logs consolidation and wipeout will\nalso rewrite logs and cause updates.\n\nBoth of continuous and batched logs are handled the same way by\ntime_schedule: Dreampipe considers the first change after each timestamp\nin the schedule to trigger the computation.\n\n --\n\n[1] The details of how LogSelector affects computations are somewhat\n    intricate. In general, the time points define \"buckets\", and any\n    versions that fall into the same bucket are equivalent (and do not\n    cause recomputations).\n\n    The general algorithm is that Dreampipe waits until the next time\n    point in the schedule, and uses the latest eligible input available\n    to schedule the computation. For recomputation, we additionally\n    require that the version of the input must be different from the\n    previously completed computation. When this rule applies, the latest\n    eligible input version is chosen from that bucket.\n\n    However, if no eligible input is available at that time point,\n    Dreampipe will wait for suitable input appears after that timepoint\n    (i.e. in the next bucket), and trigger the computation as soon as it\n    appears. When this rule applies, the previous bucket gets no version,\n    and the first version in the bucket is chosen to represent that bucket.\n\n    Note that as a result of these rules, the input version representing\n    a bucket might not always be the latest input. In particular, this\n    might happen:\n\n      * if InputLocality is used to affect input visibility (e.g.\n        dual-homed loge/loga launcher), or\n      * if a version falling into a bucket appears later (i.e. it is back-\n        dated), or\n      * if we skipped computing in previous bucket because no new version\n        was available (the second rule above)."
                }
            },
            "type": "object"
        },
        "DreampipeDefinitionSawmill..SawmillLog": {
            "description": "SawmillLog describes a Sawmill log to be used as input to a Dreampipe\ncontrolled computation.",
            "id": "DreampipeDefinitionSawmill..SawmillLog",
            "properties": {
                "logSelector": {
                    "$ref": "DreampipeDefinitionSawmill..LogSelector",
                    "description": "LogSelector chooses which versions of the log trigger computations or\nupdates. If no LogSelector is defined, a default one is used which\nschedules updates at least after the end of the logging day.\n\nIf there is already a version available at the time point specified by the\nlog_selector schedule, Dreampipe will schedule a computation using that\nversion. In this case, the version timestamp will be less than the point\nin the schedule.\n\nIf there are no versions available at that timestamp, Dreampipe will\nwait for the first version to appear after that timestamp."
                },
                "logType": {
                    "type": "string"
                },
                "shard": {
                    "description": "Some Sawmill logs are subdivided into smaller subunits called shards, see\nhttp://cs/?q=symbol:logs.LogSpecification.shards. Use this field to specify\na list of shards to use as input. If not set, all shards of the log are\nused. Note: currently Dreampipe does not separately track each shard, so\nchanges in one shard will trigger changes in all shards.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "sourceType": {
                    "description": "Sawmill logs (native or processed logs).",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeInternalComputation..Info": {
            "description": "The non-differentiating variables of this node. Holds additional information\npertaining to the node.",
            "id": "DreampipeInternalComputation..Info",
            "properties": {
                "existingDreampipe": {
                    "$ref": "DreampipeInternalComputation.Info.ExistingDreampipe"
                },
                "missingDreampipe": {
                    "$ref": "DreampipeInternalComputation.Info.MissingDreampipe"
                }
            },
            "type": "object"
        },
        "DreampipeInternalComputation..InputGroup": {
            "description": "InputGroup has information about the inputs required for a computation.",
            "id": "DreampipeInternalComputation..InputGroup",
            "properties": {
                "inputDef": {
                    "$ref": "DreampipeDefinition..InputDef"
                },
                "inputs": {
                    "items": {
                        "$ref": "DreampipeInternalComputation..Vars"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "DreampipeInternalComputation..Node": {
            "description": "Node represents either an existing output or input instance version or a\nmissing one that should be computed in the future. Node is uniquely\nidentified by Vars. Nodes form a computation graph where each node holds the\nvars of other nodes that were used as input or are required to compute the\nnode. These are used to construct the dependencies (edges) of the graph.",
            "id": "DreampipeInternalComputation..Node",
            "properties": {
                "availability": {
                    "description": "The latest information about availability of this version.",
                    "enum": [
                        "UNKNOWN",
                        "AVAILABLE",
                        "DELETED",
                        "NOT_AVAILABLE",
                        "PENDING",
                        "BLOCKED",
                        "OUTSIDE_RETENTION_PERIOD",
                        "OUTSIDE_SCHEDULING_RANGE",
                        "OUTSIDE_MANDATE",
                        "METADATA_MISSING"
                    ],
                    "enumDescriptions": [
                        "We don't know if the version is available or not.",
                        "Version is available for reading and scheduling.",
                        "Version is unavailable, because data has been deleted.",
                        "This version is not available because of other reasons besides the ones\nmentioned.",
                        "Version is currently in the queue for computation.",
                        "At least one of the versions dependencies are not available\n(deleted/pending/not_available/unknown).",
                        "Instance outside the retention period.",
                        "Instance outside the scheduling range.",
                        "Instance will not get computed for the mandate.",
                        "The instance version was used to compute downstream dependencies and is\nstill referenced from them, however it was deleted from Spanner."
                    ],
                    "type": "string"
                },
                "dependencies": {
                    "description": "Dependencies stores the Vars (identifiers) of the input dependencies.",
                    "items": {
                        "$ref": "DreampipeInternalComputation..InputGroup"
                    },
                    "type": "array"
                },
                "info": {
                    "$ref": "DreampipeInternalComputation..Info"
                },
                "location": {
                    "description": "The location(s) where the data of the version are stored. Note that\neach location should contain equivalent data (possibly in different\nformats). This is populated only for nodes that represent\nexisting instance version.",
                    "items": {
                        "$ref": "DreampipeInternalInstance..VersionLocation"
                    },
                    "type": "array"
                },
                "vars": {
                    "$ref": "DreampipeInternalComputation..Vars"
                }
            },
            "type": "object"
        },
        "DreampipeInternalComputation..Vars": {
            "description": "Vars globally uniquely identify a Node.",
            "id": "DreampipeInternalComputation..Vars",
            "properties": {
                "domain": {
                    "description": "Either the output or the input domain.",
                    "type": "string"
                },
                "existing": {
                    "$ref": "DreampipeInternalComputation.Vars.Existing"
                },
                "instanceId": {
                    "description": "Instance id is generated using the instance_vars and identifies the\ninstance of the output or the input.",
                    "type": "string"
                },
                "instanceVars": {
                    "$ref": "DreampipeInternalInstance..InstanceVars",
                    "description": "Instance vars identifies the instance of the output or the input."
                },
                "missingBunyan": {
                    "$ref": "DreampipeInternalComputation.Vars.MissingBunyan"
                },
                "missingCustom": {
                    "$ref": "DreampipeInternalComputation.Vars.MissingCustom"
                },
                "missingDreampipe": {
                    "$ref": "DreampipeInternalComputation.Vars.MissingDreampipe"
                },
                "missingFile": {
                    "$ref": "DreampipeInternalComputation.Vars.MissingFile"
                },
                "missingSawmill": {
                    "$ref": "DreampipeInternalComputation.Vars.MissingSawmill"
                },
                "name": {
                    "description": "Either the output of the input name.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeInternalComputation.Info.ExistingDreampipe": {
            "description": "ExistingDreampipe contains info pertaining to an existing Dreampipe output\ninstance version.",
            "id": "DreampipeInternalComputation.Info.ExistingDreampipe",
            "properties": {
                "outputDefTimestamp": {
                    "description": "The timestamp identifies the version of the OutputDef.",
                    "format": "int64",
                    "type": "string"
                },
                "stats": {
                    "$ref": "DreampipeInternalComputation.InfoExistingDreampipe.Stats"
                }
            },
            "type": "object"
        },
        "DreampipeInternalComputation.Info.MissingDreampipe": {
            "description": "MissingDreampipe contains info pertaining to a version of an instance that\nhas not yet been completed.",
            "id": "DreampipeInternalComputation.Info.MissingDreampipe",
            "properties": {
                "failedAttemptsCount": {
                    "description": "Number of latest consecutive failed attempts.",
                    "format": "int32",
                    "type": "integer"
                }
            },
            "type": "object"
        },
        "DreampipeInternalComputation.InfoExistingDreampipe.Stats": {
            "description": "Stats describing the computation requirements/environment.",
            "id": "DreampipeInternalComputation.InfoExistingDreampipe.Stats",
            "properties": {
                "duration": {
                    "description": "How long took the computation for the instance version to finish.",
                    "format": "google-duration",
                    "type": "string"
                },
                "startTime": {
                    "description": "Time when the computation for the instance version started.",
                    "format": "google-datetime",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeInternalComputation.Vars.Existing": {
            "description": "Existing output or input instance version. The version is identified by its\nversion vars.",
            "id": "DreampipeInternalComputation.Vars.Existing",
            "properties": {
                "vars": {
                    "$ref": "DreampipeInternalInstance..VersionVars"
                }
            },
            "type": "object"
        },
        "DreampipeInternalComputation.Vars.MissingBunyan": {
            "description": "Bunyan input instance version that does not yet exist.",
            "id": "DreampipeInternalComputation.Vars.MissingBunyan",
            "properties": {},
            "type": "object"
        },
        "DreampipeInternalComputation.Vars.MissingCustom": {
            "description": "Custom input instance version that does not yet exist.",
            "id": "DreampipeInternalComputation.Vars.MissingCustom",
            "properties": {},
            "type": "object"
        },
        "DreampipeInternalComputation.Vars.MissingDreampipe": {
            "description": "Output instance version that has not yet been completed.",
            "id": "DreampipeInternalComputation.Vars.MissingDreampipe",
            "properties": {
                "backfillId": {
                    "description": "Backfill id is set same as the backfill id in the request if it also\ntriggered the recomputation of this instance. If not, it is left empty.",
                    "format": "int64",
                    "type": "string"
                },
                "mandateId": {
                    "description": "It is possible for the computation graph to contain several nodes each\nbelonging to a missing version of the same instance however they would\nfulfill different mandates, thus mandate id is one of the identifiers for\nmissing version.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeInternalComputation.Vars.MissingFile": {
            "description": "File input instance version that does not yet exist.",
            "id": "DreampipeInternalComputation.Vars.MissingFile",
            "properties": {},
            "type": "object"
        },
        "DreampipeInternalComputation.Vars.MissingSawmill": {
            "description": "Sawmill log input instance version that does not yet exist.",
            "id": "DreampipeInternalComputation.Vars.MissingSawmill",
            "properties": {},
            "type": "object"
        },
        "DreampipeInternalInstance..Instance": {
            "description": "The \"Instance\" is a common abstraction for both instantiated (external)\ninputs and Dreampipe outputs. Keeping them as one abstraction makes the\ncode more uniform.",
            "id": "DreampipeInternalInstance..Instance",
            "properties": {
                "domain": {
                    "description": "This defines the domain of the input or output instance (i.e. corresponds\nto key fields InputInstances.InputDomain or OutputInstances.OutputDomain\nin Spanner). This field is not populated when stored in spanner; the\ncorresponding Spanner key field is used instead.",
                    "type": "string"
                },
                "name": {
                    "description": "This defines the name of the input or output instance (i.e. corresponds\nto key fields InputInstances.InputName or OutputInstances.OutputName\nin Spanner). This field is not populated when stored in spanner; the\ncorresponding Spanner key field is used instead.",
                    "type": "string"
                },
                "vars": {
                    "$ref": "DreampipeInternalInstance..InstanceVars",
                    "description": "An InstanceVars proto uniquely defines the identity of this instance. For a\nSawmill log input, the InstanceVars proto only contains the date."
                },
                "version": {
                    "description": "All currently known versions of this instance. For some instances, there\nwill only ever be one version. An example of a multi-version Instance are\nthe AdEvents logs, which are updated multiple times for any given date\n(see http://go/adevents/availability).",
                    "items": {
                        "$ref": "DreampipeInternalInstance..Version"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "DreampipeInternalInstance..InstanceVars": {
            "description": "The variables pertaining to this instance. Note that the InstanceVars\nmessage defines the identity of an instance.\n\nNote that the InstanceId field in the Spanner schema is derived from the\nInstanceVars message. This mapping should have an easy textual representation\nto make debugging the Spanner datastore easier. The mapping is defined\nas follows:\n\n * Each InstanceVars field (tag) has a canonical representation (documented\n   together with each field). This canonical representation cannot include\n   the separator character (see below).\n\n * The canonical representation for a tag is chosen such that it unique\n   to that tag.\n\n * The canonical representations are concatenated together with a separator\n   character of comma.\n\n * The fields are concatenated in tag order. Fields not present in the\n   proto are skipped.",
            "id": "DreampipeInternalInstance..InstanceVars",
            "properties": {
                "dateTime": {
                    "description": "For periodic or dated instances, this is the corresponding date-time.\n\nSyntax: subset of ISO8601, either 2014-11-13 or 2014-11-13T13:45:55.\nThe short format represents the time instant 0:00:00 on a calendar day in\na specified timezone, whereas the long format represents a timestamp\nexpressed as UTC time.\n\nEach date_time also comes with an associated timezone; it may be implied\nor explicit. For outputs, it's always the OutputDef.timezone of the last\nOutputDef. For e.g. sawmill logs, America/Los_Angeles is generally assumed.\n\nWhen doing PERIOD_CALENDAR_DAY or PERIOD_CALENDAR_MONTH dependency checks,\nthe dependency is in terms of calendar days; i.e. you can express a\ndependency across instances that are on different timezones, and the\ndependency uses the date part of the time. For PERIOD_SECOND, the exact\ntimestamp is used.\n\nCanonical InstanceId: date_time (verbatim, with no prefix).",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeInternalInstance..Version": {
            "description": "There may be multiple versions of the same instance. This applies to both\ninput instances (e.g. a new AdEvents dump) or output instances\n(recomputations).\n\nNote also that multiple Versions of the same Instance may be valid at the\nsame time. For example, many logs have instances in loga and loge clusters,\nand these aren't necessarily identical (so they aren't VersionLocations).\n\nAs a rule, all versions that are marked as AVAILABLE are available for\nreading. Typically, you'll want to use the latest versions, and the later\nversions are stored in increasing indices within the Instance proto.\n\nNote that the index of a version may change within the Instance proto.\nThe identity of a Version is given by the VersionVars proto.",
            "id": "DreampipeInternalInstance..Version",
            "properties": {
                "availability": {
                    "description": "The latest information about availability of this version. The availability\nwill get updated when the status of the version changes.",
                    "enum": [
                        "UNKNOWN",
                        "AVAILABLE",
                        "NOT_AVAILABLE"
                    ],
                    "enumDescriptions": [
                        "We don't know if the version is available or not.",
                        "Version is available for reading and scheduling. (Note that if the cell\nin question is in PCR or the service drained, it is tracked by Dreampipe\nat runtime.)",
                        "Version is unavailable, and there is no expectation of it ever returning.\nFor example, the data has been deleted."
                    ],
                    "type": "string"
                },
                "info": {
                    "$ref": "DreampipeInternalInstance..VersionInfo",
                    "description": "The vars that otherwise pertain to this Version, but do not affect the\nidentity."
                },
                "location": {
                    "description": "The location(s) where the data of the version are stored. Note that each\nlocation should contain equivalent data (possibly in different formats).",
                    "items": {
                        "$ref": "DreampipeInternalInstance..VersionLocation"
                    },
                    "type": "array"
                },
                "removedLocation": {
                    "description": "The location(s) where the data of the version used to be stored, but are no\nlonger associated with this version.",
                    "items": {
                        "$ref": "DreampipeInternalInstance..VersionLocation"
                    },
                    "type": "array"
                },
                "vars": {
                    "$ref": "DreampipeInternalInstance..VersionVars",
                    "description": "The vars represents the identity of this Version. Within an Instance,\neach Version.vars must be distinct."
                }
            },
            "type": "object"
        },
        "DreampipeInternalInstance..VersionFeatures": {
            "description": "VersionFeatures contains the output of InputDef.version_feature_extractor.",
            "id": "DreampipeInternalInstance..VersionFeatures",
            "properties": {
                "valueGooglesqlLiteral": {
                    "description": "See dreampipe.output.InputVersionFeatures.value_googlesql_literal for\nsemantics and format of this field.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeInternalInstance..VersionInfo": {
            "description": "The non-differentiating variables of this version.",
            "id": "DreampipeInternalInstance..VersionInfo",
            "properties": {
                "dreampipe": {
                    "$ref": "DreampipeInternalInstance.VersionInfo.Dreampipe"
                },
                "file": {
                    "$ref": "DreampipeInternalInstance.VersionInfo.File"
                },
                "lockId": {
                    "description": "The lock_id identifying the computation attempt. Optional; only set if\nthe complete request provided the lock_id.",
                    "format": "uint64",
                    "type": "string"
                },
                "log": {
                    "$ref": "LogInfo"
                }
            },
            "type": "object"
        },
        "DreampipeInternalInstance..VersionLocation": {
            "description": "The location of this version of the instance.",
            "id": "DreampipeInternalInstance..VersionLocation",
            "properties": {
                "format": {
                    "description": "The format of this location (e.g. recordio, columnio).",
                    "type": "string"
                },
                "pattern": {
                    "description": "The \"pattern\" can store anything and it is not specific to files. The\ninterpretation depends on the InputDef type.\n\nFor File instances, this is a google3 File API filename glob pattern.\n\nFor Sawmill logs of type AdEvents, this is the google File API filename\nglob pattern. AdEvents may be stored in multiple formats (mill, columnio),\nthis is reflected in the \"format\". However, note that VersionVars.AdEvents\nhas sufficient information about the identity of the AdEvents to find\nthe AdEvents in the usual locations.\n\nFor Dreampipe instances stored in files, this is the google File API\nfilename glob pattern.\n\nFor Bunyan instance locations stored as columnio, csv, recordio, sstable,\nthis is the google File API filename glob pattern. However, note that\nVersionVars.Bunyan has sufficient information about the abstract identity\nof the Bunyan signal-date (i.e. the dts) to locate the data using a\n\"from bunyan()\" PDQL query.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeInternalInstance..VersionVars": {
            "description": "The differentiating variables of this version.",
            "id": "DreampipeInternalInstance..VersionVars",
            "properties": {
                "bunyan": {
                    "$ref": "DreampipeInternalInstance.VersionVars.Bunyan"
                },
                "dreampipe": {
                    "$ref": "DreampipeInternalInstance.VersionVars.Dreampipe"
                },
                "file": {
                    "$ref": "DreampipeInternalInstance.VersionVars.File"
                },
                "logVersion": {
                    "$ref": "DreampipeInternalInstance.VersionVars.LogVersion"
                }
            },
            "type": "object"
        },
        "DreampipeInternalInstance.VersionInfo.Dreampipe": {
            "id": "DreampipeInternalInstance.VersionInfo.Dreampipe",
            "properties": {
                "dependency": {
                    "description": "The dependencies that were used to produce this version.",
                    "items": {
                        "$ref": "DreampipeInternalInstance.VersionInfoDreampipe.Dependency"
                    },
                    "type": "array"
                },
                "outputDefTimestamp": {
                    "description": "The OutputDef that was used to produce this data.",
                    "format": "int64",
                    "type": "string"
                },
                "runInfo": {
                    "$ref": "RunInfo",
                    "description": "The run-time environment that was responsible for producing this version."
                },
                "triggerBackfill": {
                    "description": "If the computation of this version was triggered by manual backfills, we\nstore their IDs here. If the corresponding output instance had no\nversions calculated when this version was computed (i.e. this version is\nthe first for this instance), this field will contain all backfill\nrequests that had this instance selected. If the corresponding output\ninstance already had computed instances, this field will contain those\nbackfill requests that considered the latest version at that point\nunfulfilled.",
                    "items": {
                        "format": "int64",
                        "type": "string"
                    },
                    "type": "array"
                },
                "versionTimestampUs": {
                    "description": "The borglet timestamp in microseconds when the version was committed to\nDreampipe. Note that this isn't a Spanner commit timestamp, so it is not\nordered in strict commit order.",
                    "format": "int64",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeInternalInstance.VersionInfo.File": {
            "id": "DreampipeInternalInstance.VersionInfo.File",
            "properties": {
                "mtimeNsecs": {
                    "description": "The last modified time in nanoseconds from the epoch.",
                    "format": "int64",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeInternalInstance.VersionInfoDreampipe.Dependency": {
            "id": "DreampipeInternalInstance.VersionInfoDreampipe.Dependency",
            "properties": {
                "inputName": {
                    "description": "Set to InputDef.name, identifying the role in which a file was\nconsumed. This is to accommodate the (arguably rare) case where\nthe same version is consumed twice in different roles. Together with\noutput_def_timestamp, this also binds the dependency to an actual\ninstance.\n\nIf the same input has multiple instances (i.e. len(InputDef.offset)\nis 2 or more), each instance is included separately.",
                    "type": "string"
                },
                "instance": {
                    "$ref": "DreampipeInternalInstance..InstanceVars",
                    "description": "From Instance.vars."
                },
                "version": {
                    "$ref": "DreampipeInternalInstance..VersionVars",
                    "description": "From Version.vars."
                },
                "versionFeatures": {
                    "$ref": "DreampipeInternalInstance..VersionFeatures",
                    "description": "Result of evaluating the version_feature_extractor of the corresponding\ndependency on the consumed input version."
                }
            },
            "type": "object"
        },
        "DreampipeInternalInstance.VersionVars.Bunyan": {
            "id": "DreampipeInternalInstance.VersionVars.Bunyan",
            "properties": {
                "dts": {
                    "description": "The \"dts\", a data timestamp in microseconds that identifies Bunyan data\nversions.",
                    "format": "int64",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeInternalInstance.VersionVars.Dreampipe": {
            "id": "DreampipeInternalInstance.VersionVars.Dreampipe",
            "properties": {
                "dependencyHash": {
                    "description": "This is a 64-bit hash all the dependencies that went to producing this\ndata. The hash is defined as the 64-bit sum of Fingerprint2011s of the\nVersionInfo.Dreampipe.Dependency protocol buffers. The fingerprint\nis calculated from the serialized byte buffer, with tags 1..3 set.\n\nFor rationale why the the + operator is used, see CombineUnordered() in\nutil/hash/fingerprinting.h.",
                    "format": "uint64",
                    "type": "string"
                },
                "outputTimestamp": {
                    "description": "OutputDef.timestamp identifies the version of the OutputDef that produced\nthis version.",
                    "format": "int64",
                    "type": "string"
                },
                "uuid": {
                    "description": "uuid uniquely identifies this version. dependency_hash and\noutput_timestamp are not enough to distinguish versions that were\ncomputed out of the same inputs.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeInternalInstance.VersionVars.File": {
            "id": "DreampipeInternalInstance.VersionVars.File",
            "properties": {
                "version": {
                    "description": "All version-impacting variables of this File version. If there are\nmultiple fields, they should be in the order in which they affect\nthe sorting order.\n\nThe meaning of of each field index is implicitly defined by the\nTrackedInput (which, in turn, should come from InputDef).\n\n# Sorting order\n\nAs other versions, we order the instances such that up-to-date instances\nare at the end of the list.\n\nThe version ordering is defined as follows:\n\n(1) the entire array of version strings is ordered in dictionary order;\n(2) within each version string, we use normal dictionary order.\n\n# Version identity\n\n(1) An explicit path component captured by the {version} variable.\n\n    This is the recommended approach. The version variable matches any\n    path component (except '/'). We also support supplementary variables\n    {version/1}, {version/2} etc.\n\n(2) Implicit version variable based on the timestamp of the file.\n\n    If no explicit path is provided, we synthesize a version variable\n    with three components:\n\n    (a) the modification timestamp of the file, encoded as\n        YYYY-MM-DDTHH:MM:SS.NNNNNNNNN in UTC timezone. If the file has\n        multiple paths, the latest modification timestamp is used;\n\n    (b) the number of matching files; needed as part of the version\n        identity in addition to (a) to account for the case where new,\n        previous unseen files with smaller mod-time match the glob\n        pattern;\n\n    (c) The number of bytes in files matched, needed as additional\n        safeguard in case file size changes without mod-time changing.\n\nNote that technically the Sorting order rule (2) is inconsistent for (b)\nand (c), because it e.g. sorts \"10\" < \"8\" < \"9\" . So it doesn't sort the\nsizes in increasing nor decreasing order. However, if the modification\ntimestamps are identical, we use the other field just as differentiators,\nas there is no guarantee that a file version with more bytes is in any\nsense \"newer\" than other files.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "DreampipeInternalInstance.VersionVars.LogVersion": {
            "id": "DreampipeInternalInstance.VersionVars.LogVersion",
            "properties": {
                "extraId": {
                    "description": "For logs which have an extra non-stamp identifier (e.g. the GUID of the\nAdEvents logs), that part is stored here. If there is no GUID, leave\nunset.",
                    "type": "string"
                },
                "generationCell": {
                    "description": "For cells where the contents is different depending on cell\n(e.g. AdEvents), this contains the generation cell.\nFor other logs, leave unset.",
                    "type": "string"
                },
                "timestampNs": {
                    "description": "For non-batched logs, timestamp identifies the time when Dreampipe\ndetected that the log appeared or had changed. For batched jobs, it\nidentifies a time of the log (e.g. a file timestamp).\n\nIn case of AdEvents, this contains the timestamp part of the embedded\nUID of the AdEvents file. E.g. with the special case of the GUID\ntimestamp (20090604212107_00000121aea61e1700ac0019002c002333be22c5),\nwe store:\n  timestamp_ns=1244175667000000000\n  extra_id=_00000121aea61e1700ac0019002c002333be22c5 (with underscore)",
                    "format": "uint64",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeInternalLock..LockInfo": {
            "id": "DreampipeInternalLock..LockInfo",
            "properties": {
                "instance": {
                    "description": "Keep a record which instances were locked in the previous AcquireLock\nor ExtendLock call; this is needed during lock extension mainly for\nthe STEAL_* LockingOptions (i.e. we need to know what we once had, so that\nwe can steal it back). It's also used to construct the list of\nOutputs for LockStatus.",
                    "items": {
                        "$ref": "DreampipeInternalLock..LockedInstance"
                    },
                    "type": "array"
                },
                "lockingStrategyKey": {
                    "enum": [
                        "UNKNOWN_LOCKING_KEY",
                        "INSTANCE_KEY",
                        "MANDATE_INSTANCE_KEY"
                    ],
                    "enumDescriptions": [
                        "",
                        "Default locking key. This is preferable option for domains which don't use\nmandates. It is based on domain name, output name and instance id.\n\nIt prevents two parallel computations of the same specific instance (even\nif the inputs/output version would be different).",
                        "Preferable option for domains using mandates. It is based on domain\nname, output name, instance id and mandate id.\n\nIt prevents two parallel computations of the same specific instance within\nmandate (even if the inputs/output version would be different) but allows\nparallel computations of the same instance within different mandates."
                    ],
                    "type": "string"
                },
                "outputInstance": {
                    "description": "Keep a record which computations were locked in the previous AcquireLock\nor ExtendLock call; this is needed during lock extension mainly for\nthe STEAL_* LockingOptions (i.e. we need to know what we once had, so that\nwe can steal it back).",
                    "items": {
                        "$ref": "DreampipeOutput..OutputInstance"
                    },
                    "type": "array"
                },
                "owner": {
                    "description": "The user who originally acquired this lock.",
                    "type": "string"
                },
                "runInfo": {
                    "$ref": "RunInfo"
                },
                "runnerJob": {
                    "$ref": "RunnerJob",
                    "description": "Keep a record of the runner job associated with the lock."
                }
            },
            "type": "object"
        },
        "DreampipeInternalLock..LockedInstance": {
            "id": "DreampipeInternalLock..LockedInstance",
            "properties": {
                "domain": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "vars": {
                    "$ref": "DreampipeInternalInstance..InstanceVars"
                }
            },
            "type": "object"
        },
        "DreampipeInternalRestrictedApi..GetOutputDefSchedulingStatusResponse": {
            "id": "DreampipeInternalRestrictedApi..GetOutputDefSchedulingStatusResponse",
            "properties": {
                "domain": {
                    "description": "Same as request.domain.",
                    "type": "string"
                },
                "mandateId": {
                    "description": "Contains request Restriction_mandate_id.\nSet iff request Restriction_mandate_id was set.",
                    "type": "string"
                },
                "name": {
                    "description": "Same as request.name.",
                    "type": "string"
                },
                "status": {
                    "enum": [
                        "UNSPECIFIED",
                        "ACTIVE",
                        "PAUSED"
                    ],
                    "enumDescriptions": [
                        "Not to be used. See go/protodosdonts.",
                        "OutputDef can be used for computing pending instances.",
                        "OutputDef cannot be used for computing pending instances."
                    ],
                    "type": "string"
                },
                "timestamp": {
                    "description": "Contains the timestamp of the OutputDef which was affected.\nSet iff request Restriction_mandate_id was not set",
                    "format": "int64",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeInternalRestrictedApi..OutputDeletionRequest": {
            "id": "DreampipeInternalRestrictedApi..OutputDeletionRequest",
            "properties": {
                "deleteAllConfirm": {
                    "description": "Additional confirmation for deleting all outputs.",
                    "type": "boolean"
                },
                "dryRun": {
                    "type": "boolean"
                },
                "outputs": {
                    "description": "If no outputs are specified, all outputs from the domain are deleted. If\nyou want to delete all outputs, additionally delete_all_confirm needs to be\nset.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "DreampipeInternalRestrictedApi..OutputDeletionResponse": {
            "id": "DreampipeInternalRestrictedApi..OutputDeletionResponse",
            "properties": {
                "domain": {
                    "description": "Same as OutputDeletionRequest.domain.",
                    "type": "string"
                },
                "inputInstanceCount": {
                    "items": {
                        "format": "int32",
                        "type": "integer"
                    },
                    "type": "array"
                },
                "inputs": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "mandateIds": {
                    "description": "IDs of the mandates which will be changed by this deletion, sorted\nlexicographically.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "outputInstanceCount": {
                    "description": "Counts of deleted instances of the respective outputs (i.e. the same index)\nfrom the outputs field.",
                    "items": {
                        "format": "int32",
                        "type": "integer"
                    },
                    "type": "array"
                },
                "outputs": {
                    "description": "Names of all deleted outputs, sorted lexicographically.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "DreampipeInternalRestrictedApi..OverrideAttemptCountRequest": {
            "description": "Request to override the attempt count for the specified instances. If no\ninstances are specified, attempts from all instances are overridden.\nIf mandate_id is specified, only the attempts which fulfill the mandate\nare overridden.\nOnce the attempt is overridden it stays overridden even if the mandate\nchanges.",
            "id": "DreampipeInternalRestrictedApi..OverrideAttemptCountRequest",
            "properties": {
                "attemptCountOverride": {
                    "description": "Deprecated, only 0 is supported.",
                    "format": "int32",
                    "type": "integer"
                },
                "instances": {
                    "items": {
                        "$ref": "DreampipeOutput..OutputVars"
                    },
                    "type": "array"
                },
                "mandateId": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeInternalRestrictedApi..OverrideAttemptCountResponse": {
            "id": "DreampipeInternalRestrictedApi..OverrideAttemptCountResponse",
            "properties": {
                "overriddenCount": {
                    "description": "Number of instances whose execution attempt count has been overridden.",
                    "format": "int32",
                    "type": "integer"
                }
            },
            "type": "object"
        },
        "DreampipeInternalRestrictedApi..SetOutputDefSchedulingStatusRequest": {
            "description": "Request to set the specified scheduling status for output def identified by\nthe specified domain, name and timestamp. If the timestamp is not specified,\nthe latest output def will be updated.",
            "id": "DreampipeInternalRestrictedApi..SetOutputDefSchedulingStatusRequest",
            "properties": {
                "mandateId": {
                    "description": "If set, output status is modified within the provided mandate. If not,\nwe disable output within the default mandate.",
                    "type": "string"
                },
                "status": {
                    "enum": [
                        "UNSPECIFIED",
                        "ACTIVE",
                        "PAUSED"
                    ],
                    "enumDescriptions": [
                        "Not to be used. See go/protodosdonts.",
                        "OutputDef can be used for computing pending instances.",
                        "OutputDef cannot be used for computing pending instances."
                    ],
                    "type": "string"
                },
                "timestamp": {
                    "description": "If set, output status is modified for the particular OutputDef within\nthe default mandate.",
                    "format": "int64",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeInternalRestrictedApi..SetOutputDefSchedulingStatusResponse": {
            "id": "DreampipeInternalRestrictedApi..SetOutputDefSchedulingStatusResponse",
            "properties": {},
            "type": "object"
        },
        "DreampipeInternalRestrictedApi..TestPermissionsRequest": {
            "description": "TestPermissionsRequest for checking whether the calling user or any prod\ngroup they belong to has been granted the specified roles for the given\ntarget.",
            "id": "DreampipeInternalRestrictedApi..TestPermissionsRequest",
            "properties": {
                "roles": {
                    "enumDescriptions": [
                        "",
                        "This role can only be set for a domain target. Following RPCs may be\ninvoked by domain readers:\n  - ListBackfills\n  - ListPrincipals\n  - GetDomainInfo\n  - QueryPendingDeletions",
                        "This role can only be set for a domain target. Following RPCs may be\ninvoked by domain writers:\n  - GrantAccess\n  - RevokeAccess\n  - CreateBackfillVersion\n  - ListBackfills\n  - SetBackfillStatus\n  - ListPrincipals\n  - BulkInsertOrUpdateOutput\n  - PushRetentionPolicies // TODO(b/66157858)\n  - QueryPendingDeletions\n  - ReportDeleted\n  - GetDomainInfo",
                        "This role can be defined for both a domain and a mandate target. Following\nRPCs may be invoked by mandate readers:\n  - ListMandates\n  - ListPrincipals\nNOTE: Mandate feature has not yet been launched, this role should not be\nused.",
                        "This role can be defined for both a domain and a mandate target. Following\nRPCs may be invoked by mandate writers:\n  - CreateMandateVersion\n  - ListMandates\n  - GrantAccess\n  - RevokeAccess\n  - ListPrincipals\nNOTE: Mandate feature has not yet been launched, this role should not be\nused.",
                        "This role can only be set for a domain target. Following RPCs may be\ninvoked by backfill readers:\n  - ListBackfills",
                        "This role can only be set for a domain target. Following RPCs may be\ninvoked by backfill writers:\n  - CreateBackfillVersion\n  - ListBackfills\n  - SetBackfillStatus",
                        "This role can only be set for a domain target. Following RPCs may be\ninvoked by retention reader:\n  - ReadRetention",
                        "This role can only be set for a domain target. Following RPCs may be\ninvoked by retention writers:\n  - PushRetention\n  - ReadRetention",
                        "This role can only be set for a launcher_pool target. Following RPCs may\nbe invoked by launcher pool writers:\n - QueryActiveRunners",
                        "This role can only be set for a domain target. Following RPCs may be\ninvoked by output readers:\n  - BulkLookupOutputs",
                        "This role can only be set for a domain target. Following RPCs may be\ninvoked by output writers:\n  - BulkLookupOutputs\n  - DeleteOutputs\n  - BulkInsertOrUpdateOutput",
                        "This role can be set for a domain and a mandate target. Following RPCs\nmay be invoked by instance reader:\n  - QueryPendingInstances (without claiming the lock)\n  - QueryCompletedInstances",
                        "This role can be set for a domain and a mandate target. Following RPCs\nmay be invoked by exec attempts writer:\n  - OverrideAttemptCount",
                        "This role can be set for a domain and a mandate target. Following RPCs\nmay be invoked by scheduling status reader:\n  - GetOutputDefSchedulingStatus",
                        "This role can be set for a domain and a mandate target. Following RPCs\nmay be invoked by scheduling status writer:\n  - GetOutputDefSchedulingStatus\n  - SetOutputDefSchedulingStatus"
                    ],
                    "items": {
                        "enum": [
                            "ROLE_UNKNOWN",
                            "ROLE_DOMAIN_READER",
                            "ROLE_DOMAIN_WRITER",
                            "ROLE_MANDATE_READER",
                            "ROLE_MANDATE_WRITER",
                            "ROLE_BACKFILL_READER",
                            "ROLE_BACKFILL_WRITER",
                            "ROLE_RETENTION_READER",
                            "ROLE_RETENTION_WRITER",
                            "ROLE_LAUNCHER_POOL_WRITER",
                            "ROLE_OUTPUT_READER",
                            "ROLE_OUTPUT_WRITER",
                            "ROLE_INSTANCE_READER",
                            "ROLE_EXEC_ATTEMPTS_WRITER",
                            "ROLE_SCHEDULING_STATUS_READER",
                            "ROLE_SCHEDULING_STATUS_WRITER"
                        ],
                        "type": "string"
                    },
                    "type": "array"
                },
                "target": {
                    "$ref": "DreampipeAcl..Target"
                }
            },
            "type": "object"
        },
        "DreampipeInternalRestrictedApi..TestPermissionsResponse": {
            "id": "DreampipeInternalRestrictedApi..TestPermissionsResponse",
            "properties": {
                "roles": {
                    "description": "Subset of roles from the request which were granted to the calling user or\nany prod group they belong to for the target specified in the request.",
                    "enumDescriptions": [
                        "",
                        "This role can only be set for a domain target. Following RPCs may be\ninvoked by domain readers:\n  - ListBackfills\n  - ListPrincipals\n  - GetDomainInfo\n  - QueryPendingDeletions",
                        "This role can only be set for a domain target. Following RPCs may be\ninvoked by domain writers:\n  - GrantAccess\n  - RevokeAccess\n  - CreateBackfillVersion\n  - ListBackfills\n  - SetBackfillStatus\n  - ListPrincipals\n  - BulkInsertOrUpdateOutput\n  - PushRetentionPolicies // TODO(b/66157858)\n  - QueryPendingDeletions\n  - ReportDeleted\n  - GetDomainInfo",
                        "This role can be defined for both a domain and a mandate target. Following\nRPCs may be invoked by mandate readers:\n  - ListMandates\n  - ListPrincipals\nNOTE: Mandate feature has not yet been launched, this role should not be\nused.",
                        "This role can be defined for both a domain and a mandate target. Following\nRPCs may be invoked by mandate writers:\n  - CreateMandateVersion\n  - ListMandates\n  - GrantAccess\n  - RevokeAccess\n  - ListPrincipals\nNOTE: Mandate feature has not yet been launched, this role should not be\nused.",
                        "This role can only be set for a domain target. Following RPCs may be\ninvoked by backfill readers:\n  - ListBackfills",
                        "This role can only be set for a domain target. Following RPCs may be\ninvoked by backfill writers:\n  - CreateBackfillVersion\n  - ListBackfills\n  - SetBackfillStatus",
                        "This role can only be set for a domain target. Following RPCs may be\ninvoked by retention reader:\n  - ReadRetention",
                        "This role can only be set for a domain target. Following RPCs may be\ninvoked by retention writers:\n  - PushRetention\n  - ReadRetention",
                        "This role can only be set for a launcher_pool target. Following RPCs may\nbe invoked by launcher pool writers:\n - QueryActiveRunners",
                        "This role can only be set for a domain target. Following RPCs may be\ninvoked by output readers:\n  - BulkLookupOutputs",
                        "This role can only be set for a domain target. Following RPCs may be\ninvoked by output writers:\n  - BulkLookupOutputs\n  - DeleteOutputs\n  - BulkInsertOrUpdateOutput",
                        "This role can be set for a domain and a mandate target. Following RPCs\nmay be invoked by instance reader:\n  - QueryPendingInstances (without claiming the lock)\n  - QueryCompletedInstances",
                        "This role can be set for a domain and a mandate target. Following RPCs\nmay be invoked by exec attempts writer:\n  - OverrideAttemptCount",
                        "This role can be set for a domain and a mandate target. Following RPCs\nmay be invoked by scheduling status reader:\n  - GetOutputDefSchedulingStatus",
                        "This role can be set for a domain and a mandate target. Following RPCs\nmay be invoked by scheduling status writer:\n  - GetOutputDefSchedulingStatus\n  - SetOutputDefSchedulingStatus"
                    ],
                    "items": {
                        "enum": [
                            "ROLE_UNKNOWN",
                            "ROLE_DOMAIN_READER",
                            "ROLE_DOMAIN_WRITER",
                            "ROLE_MANDATE_READER",
                            "ROLE_MANDATE_WRITER",
                            "ROLE_BACKFILL_READER",
                            "ROLE_BACKFILL_WRITER",
                            "ROLE_RETENTION_READER",
                            "ROLE_RETENTION_WRITER",
                            "ROLE_LAUNCHER_POOL_WRITER",
                            "ROLE_OUTPUT_READER",
                            "ROLE_OUTPUT_WRITER",
                            "ROLE_INSTANCE_READER",
                            "ROLE_EXEC_ATTEMPTS_WRITER",
                            "ROLE_SCHEDULING_STATUS_READER",
                            "ROLE_SCHEDULING_STATUS_WRITER"
                        ],
                        "type": "string"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "DreampipeMandate..InstanceSelector": {
            "description": "Instance selector is a predicate used to filter instances which should be\ncomputed per some mandate.",
            "id": "DreampipeMandate..InstanceSelector",
            "properties": {
                "dateTimeRange": {
                    "$ref": "DreampipeMandate.InstanceSelector.DateTimeRange"
                }
            },
            "type": "object"
        },
        "DreampipeMandate..MandateKey": {
            "description": "MandateKey uniquely identifies a mandate.",
            "id": "DreampipeMandate..MandateKey",
            "properties": {
                "domain": {
                    "description": "Domain of all outputs contained within the mandate. Mandate can only\ncontain outputs from a single domain. This is a fully specified domain, it\nneeds to include the subdomain as well if it is used.",
                    "type": "string"
                },
                "mandateId": {
                    "description": "Unique identifier of a mandate within the domain.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeMandate..MandateVersion": {
            "description": "MandateVersion holds the data about a single mandate version.",
            "id": "DreampipeMandate..MandateVersion",
            "properties": {
                "createdBy": {
                    "description": "Logical user assumed by the peer who executed the stubby that created this\nmandate version. If the peer was a proxy, this is the role of the client\nusing the proxy, not the proxy itself.",
                    "type": "string"
                },
                "description": {
                    "description": "Description of this mandate version.",
                    "type": "string"
                },
                "mandateVersionKey": {
                    "$ref": "DreampipeMandate..MandateVersionKey",
                    "description": "Unique identifier of a mandate version."
                },
                "outputs": {
                    "description": "Output specifications defined for this mandate version.",
                    "items": {
                        "$ref": "DreampipeMandate..Output"
                    },
                    "type": "array"
                },
                "parentMandateId": {
                    "description": "Parent of this mandate version.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeMandate..MandateVersionKey": {
            "description": "MandateVersionKey uniquely identifies a specific version of a mandate.",
            "id": "DreampipeMandate..MandateVersionKey",
            "properties": {
                "mandateKey": {
                    "$ref": "DreampipeMandate..MandateKey",
                    "description": "Unique identifier of a mandate."
                },
                "versionId": {
                    "description": "Timestamp when this mandate version was created. This uniquely identifies a\nspecific version within the mandate.",
                    "format": "int64",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeMandate..Output": {
            "description": "Output specifies definitions of the output that are fulfilling the mandate\nand also specified a definition to be used for subsequent computations.",
            "id": "DreampipeMandate..Output",
            "properties": {
                "approvedDefinitions": {
                    "description": "Approved holds a list of timestamps referencing definitions of\nthis output. Instance version of this output is considered fulfilled w.r.t.\nthe mandate if it was computed per an approved output definition and all\nits inputs are fulfilled w.r.t. the mandate.\nApproved versions only applies to all instances unless\napproved_definitions_for_selected_instances is specified (or inherited) in\nwhich case we use them to decide the fulfillment only for the instances\nwhich do not fulfill the instance_selector.",
                    "items": {
                        "format": "int64",
                        "type": "string"
                    },
                    "type": "array"
                },
                "approvedDefinitionsForSelectedInstances": {
                    "description": "This field holds a list of timestamps referencing definitions of\nthis output. Instance version of this output is considered fulfilled w.r.t.\nthe mandate if it was computed per an approved output definition and all\nits inputs are fulfilled w.r.t. the mandate.\nWe only use this field for instances fulfilling the instance selector.\nIf left empty by user, we populate this field as follows:\n  - if approved_definitions is not empty, we use approved_definitions\n  - otherwise we inherit from parent mandate.",
                    "items": {
                        "format": "int64",
                        "type": "string"
                    },
                    "type": "array"
                },
                "currentDefinition": {
                    "description": "Current definition holds a timestamp referencing a definition of this\noutput to be used for scheduling subsequent computations.",
                    "format": "int64",
                    "type": "string"
                },
                "instanceSelector": {
                    "$ref": "DreampipeMandate..InstanceSelector",
                    "description": "Instance selector defines a set of output instances for which this mandate\ntakes effect. If any of the selected instances does not have a version\nfulfilling the mandate it will be eligible for computation given the\navailability and fulfillment of its inputs."
                },
                "outputName": {
                    "description": "OutputDef.name",
                    "type": "string"
                },
                "status": {
                    "description": "Status defines how to treat the output w.r.t.\nscheduling.",
                    "enum": [
                        "OUTPUT_STATUS_UNKNOWN",
                        "OUTPUT_STATUS_ACTIVE",
                        "OUTPUT_STATUS_PAUSED"
                    ],
                    "enumDescriptions": [
                        "OUTPUT_STATUS_UNKNOWN is treated as OUTPUT_STATUS_ACTIVE\nfor the backward compatibility.",
                        "OUTPUT_STATUS_ACTIVE means that output can be used\nfor scheduling.",
                        "OUTPUT_STATUS_PAUSED is used for outputs which should\nnot be scheduled within particular mandate atm."
                    ],
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeMandate.InstanceSelector.DateTimeRange": {
            "description": "Defines a time interval that applies to InstanceVars.date_time. The syntax\nneeds to match the one specified for InstanceVars.date_time. The timezone\nis handled the same way as for InstanceVars.date_time. Start boundary is\ninclusive, end boundary is exclusive. If start or end are not specified the\nrespective side of the range will be unbounded.\nTime format is a subset of ISO8601, either 2014-11-13 or\n2014-11-13T13:45:55",
            "id": "DreampipeMandate.InstanceSelector.DateTimeRange",
            "properties": {
                "end": {
                    "type": "string"
                },
                "start": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeOutput..InputGroup": {
            "id": "DreampipeOutput..InputGroup",
            "properties": {
                "location": {
                    "description": "The locations, one per input instance. This has more than one instances\nif the InputDef.offset field had more than one offsets. (Note that it\nmay have less entries than there are offsets if InputDef.num_optional\nis set.)",
                    "items": {
                        "$ref": "DreampipeOutput..InputLocation"
                    },
                    "type": "array"
                },
                "name": {
                    "description": "The name of the Input, from InputDef.name.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeOutput..InputLocation": {
            "description": "InputLocation describes a location where a specific instance version is\nstored in.\n\nNote that inputs may have multiple locations, and Dreampipe may describe the\nsame input in different ways (some more abstract in nature). For example:\n\n * Sawmill inputs are always expressed as source_type/log_type, and\n   Dreampipe may also return a concrete file path pattern.\n\n * Bunyan inputs are always expressed as signal names, and Dreampipe also\n   returns each of the file format materializations (columnio, recordio).\n   Note that Bunyan's Bigtable materializations are *not* returned.\n\n * Dreampipe inputs are primarily expressed as files, but we also return\n   an opaque token which helps connect output instances to the right instance\n   of Dreampipe inputs. This is useful e.g. when Dreampipe does not know any\n   other materializations for this input, or if those materializations are\n   ambiguous.",
            "id": "DreampipeOutput..InputLocation",
            "properties": {
                "bunyan": {
                    "$ref": "DreampipeOutput.InputLocation.Bunyan"
                },
                "dreampipe": {
                    "$ref": "DreampipeOutput.InputLocation.Dreampipe"
                },
                "file": {
                    "$ref": "DreampipeOutput.InputLocation.File",
                    "description": "These messages describe the locations in which this input exists. At least\none of these fields should be set.\n\nNote that despite the similarity in name, these protos do not correspond\n1:1 with OutputDef.InputDef.location. For example, a Sawmill InputDef\nmay correspond to InputLocation.SawmillLog (to describe it as a\nlog_type/source_type pair), but also as a InputLocation.File (if it has\na materialization e.g. as a columnio file). See \"Note\" on InputLocation."
                },
                "sawmillLog": {
                    "$ref": "DreampipeOutput.InputLocation.SawmillLog"
                },
                "vars": {
                    "$ref": "DreampipeOutput..InputVars",
                    "description": "The identifying information of the instance to which this input\nlocation belongs to."
                },
                "versionFeatures": {
                    "$ref": "DreampipeOutput..InputVersionFeatures",
                    "description": "Result of executing the version_feature_extractor of the corresponding\nInputDef on this input version."
                }
            },
            "type": "object"
        },
        "DreampipeOutput..InputVars": {
            "id": "DreampipeOutput..InputVars",
            "properties": {
                "dateTime": {
                    "description": "For periodic or dated instances, this is the corresponding date-time.\n\nSyntax: subset of ISO8601, either 2014-11-13 or 2014-11-13T13:45:55",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeOutput..InputVersionFeatures": {
            "description": "InputVersionFeatures contains the output of\nInputDef.version_feature_extractor.",
            "id": "DreampipeOutput..InputVersionFeatures",
            "properties": {
                "valueGooglesqlLiteral": {
                    "description": "A string that contains a GoogleSQL literal expression whose type\ncorresponds to the type of the InputDef.version_feature_extractor output,\nand whose value represents the output value of the extractor.\nThis could e.g. be just '1' for an extractor that returns an INT value,\nor '(\"ABC\", 123, TRUE)' for an extractor that returns a STRUCT.\nThe extractor is only allowed to return primitive types and structs,\nlimiting the set of valid values.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeOutput..OutputInstance": {
            "description": "OutputInstance describes an instance of an Output that fulfills the\nrequirements of OutputDef and is out of date with respect to\nQueryPendingInstances.",
            "id": "DreampipeOutput..OutputInstance",
            "properties": {
                "domain": {
                    "description": "The OutputDef.domain.",
                    "type": "string"
                },
                "doneTimestampMicros": {
                    "description": "The borglet timestamp in microseconds when this version of the instance\nwas committed to Dreampipe. Note that this isn't a Spanner commit\ntimestamp, so it is not ordered in strict commit order.\nNot intended to be used as a version identifier.",
                    "format": "int64",
                    "type": "string"
                },
                "existingLockId": {
                    "description": "If not zero, this instance was locked at the time when this call was made.\nThis field is populated in both QueryPendingInstances and AcquireLock\ncalls. However, because the lock_id is returned only for those\nOutputInstances that are returned by those calls, this value can only be\nset in two cases:\n\n * when STEAL_LOCKS was used to break the lock; and\n * when QUERY_IGNORE_LOCKS was used to retrieve instances ignoring\n   their current locking state.\n\nNote that the lock_id is only provided for informational use. Any use of\nthis id to perform locking is prone to race conditions.",
                    "format": "uint64",
                    "type": "string"
                },
                "inputGroup": {
                    "description": "The inputs to this output, grouped by InputDef.name. There is always an\nInputGroup entry for each OutputDef.input, even if the InputGroup is empty.",
                    "items": {
                        "$ref": "DreampipeOutput..InputGroup"
                    },
                    "type": "array"
                },
                "mandateId": {
                    "description": "Mandate this instance fulfills.",
                    "type": "string"
                },
                "name": {
                    "description": "The OutputDef.name.",
                    "type": "string"
                },
                "numPreviousAttempts": {
                    "description": "Number of previous attempts to execute this output instance. Previous\ncalls that have locked the instance either directly (AcquireLock) or\nindirectly (via PendingInstanceQuery.locking_strategy) are counted as\nprevious attempts.",
                    "format": "int32",
                    "type": "integer"
                },
                "output": {
                    "description": "OutputLocation contains information from OutputDef.location, with\nvariables fully expanded.",
                    "items": {
                        "$ref": "DreampipeOutput..OutputLocation"
                    },
                    "type": "array"
                },
                "timestamp": {
                    "description": "The OutputDef.timestamp.",
                    "format": "int64",
                    "type": "string"
                },
                "triggerBackfill": {
                    "description": "If the computation of this output instance was triggered by manual\nbackfills, we will store their IDs here.",
                    "items": {
                        "format": "int64",
                        "type": "string"
                    },
                    "type": "array"
                },
                "vars": {
                    "$ref": "DreampipeOutput..OutputVars",
                    "description": "OutputVars describes the identity of the output instance."
                }
            },
            "type": "object"
        },
        "DreampipeOutput..OutputLocation": {
            "id": "DreampipeOutput..OutputLocation",
            "properties": {
                "file": {
                    "$ref": "DreampipeOutput.OutputLocation.File"
                },
                "name": {
                    "description": "The name that gets passed to the launcher as an identifier for this output.\nThis is copied from OutputDef.location.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeOutput..OutputVars": {
            "description": "OutputVars defines the identity of the Output Instance. For periodic or\ndated instances, this is the date-time of the instance.",
            "id": "DreampipeOutput..OutputVars",
            "properties": {
                "dateTime": {
                    "description": "Syntax: subset of ISO8601, either 2014-11-13 (TZ-agnostic calendar date),\nor 2014-11-13T13:45:55 (timestamp in UTC).",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeOutput.InputLocation.Bunyan": {
            "description": "Bunyan computations.\n\nNote that this InputLocation describes the location of the Bunyan signal\nin the Bunyan metadata storage to be used with the \"FROM BUNYAN()\"\nsyntax. For most file types, we also return the file materialization\nof the computation result (see \"Note\" on InputLocation).",
            "id": "DreampipeOutput.InputLocation.Bunyan",
            "properties": {
                "dts": {
                    "description": "The \"dts\", a data timestamp, identifies specific versions of Bunyan\ndata.",
                    "format": "int64",
                    "type": "string"
                },
                "instance": {
                    "description": "The Bunyan instance, from InputDef.Bunyan.instance.",
                    "type": "string"
                },
                "signalName": {
                    "description": "The name of the signal (a materialized view) in Bunyan, from\nInputDef.Bunyan.signal_name.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeOutput.InputLocation.Dreampipe": {
            "description": "Dreampipe computation.\n\nNote that this InputLocation only serves as a token to connect inputs (i.e.\nDreampipe output instances used as inputs for the output instance this\nmessage is part of) to outputs (i.e. the newly created output instance this\nmessage is part of). This is needed when there are no input locations\n(which happens if you use Dreampipe only as a control flow tool, or if the\nactual path of the input is relayed on a side channel outside Dreampipe).\nThis message cannot be used to identify the input on the user side: if you\nneed that, you should use the other materializations (see \"Note\" on\nInputLocation).\n\nWarning: Do not construct this message manually. You should only pass the\nentire proto unchanged from a PendingInstanceQuery to the corresponding\nCompleteInstances call.",
            "id": "DreampipeOutput.InputLocation.Dreampipe",
            "properties": {
                "uuid": {
                    "description": "This UUID is an implementation detail and should not be used, see\nWarning above. (Implementation note: this corresponds to\nhttp://cs/&q=symbol:dreampipe.internal.instance.VersionVars.Dreampipe.uuid)",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeOutput.InputLocation.File": {
            "id": "DreampipeOutput.InputLocation.File",
            "properties": {
                "location": {
                    "items": {
                        "$ref": "DreampipeOutput.InputLocationFile.Location"
                    },
                    "type": "array"
                },
                "version": {
                    "description": "The version identity associated with this file path. For InputDefs of\ntype file, this corresponds to the versions captured explicitly with\nthe {version} variables.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "DreampipeOutput.InputLocation.SawmillLog": {
            "description": "Sawmill logs (native or processed logs).\n\nNote that this InputLocation describes the location of the log in\nSawmill, using the usual source_type/log_type notation. For some logs,\nwe also return the file backing the log (see \"Note\" on InputLocation).",
            "id": "DreampipeOutput.InputLocation.SawmillLog",
            "properties": {
                "cluster": {
                    "description": "The cluster (loge or loga) where this log is available. This may not be\nset for logs where availability generally doesn't depend on the cluster.",
                    "type": "string"
                },
                "logType": {
                    "type": "string"
                },
                "logVersion": {
                    "description": "The log_version identifies the version of this log. The format is the\nsame for all logs, but the meaning is different, and it's typically\nyyyyMMddHHmmss.\n\nFor processed logs that have distinct versions, this is the version\nidentifier of that generated version. A notable example is the\nhttp://go/adevents log. The AdEvents log may optionally have a _GUID\ncomponent following the datetime (see http://go/adevents-availability).\n\nFor all other logs (both processed and collected), this is the filesystem\ntimestamp in America/Los_Angeles timezone, which indicates the time when\nDreampipe has detected a change in the logs. This change may indicate\nnew events, or a rewrite e.g. because of Wipeout or logs consolidation.",
                    "type": "string"
                },
                "logsProxyReadInfo": {
                    "$ref": "DreampipeOutput.InputLocationSawmillLog.LogsProxyReadInfo",
                    "description": "If this log is an alias that resolves into multiple log units under the\nhood, logs_proxy_read_info contains the names that actually get passed to\nLogsProxy to read the data.  For example:\n\n  -- log \"ads/allcontent.AdEventsQueries\" might resolve to:\n     -- \"processed/ads/AdEventsQueriesContent\"\n     -- \"processed/ads/tmp-UnmatchedAdEventsQueries\"\n\nIf AdEventsQueriesContent is not materialized and we need to do an\non-the-fly join, then we might instead store:\n\n     -- \"processed/ads/AdQueries+AdEventsWithTransform\"\n     -- \"processed/ads/tmp-UnmatchedAdEventsQueries\"\n\nNote that \"AdQueries+AdEventsWithTransform\" is not really a log type, but\nrather a directive that LogsProxy uses to read multiple underlying logs\nand join/transform under the hood.  This directive should not be parsed\nby the user, but passed to LogsProxy verbatim."
                },
                "shard": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "sourceType": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeOutput.InputLocationFile.Location": {
            "description": "Location based on InputDef location, variable-expanded.\nIf InputDef.File.Location contained multiple candidate locations,\nthere may be more than one Locations here, and the one Dreampipe detected\nlast appears first on the list. InputRequirement.input_locality\nfiltering is applied to the returned patterns. The launcher (or runner)\nshould choose a single pattern using criteria known to it.",
            "id": "DreampipeOutput.InputLocationFile.Location",
            "properties": {
                "format": {
                    "description": "The format of this output (e.g. recordio, columnio).",
                    "type": "string"
                },
                "pattern": {
                    "description": "The pattern from InputDef.File, variable-expanded.\nThere will be at most one pattern per candidate location.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeOutput.InputLocationSawmillLog.LogsProxyReadInfo": {
            "id": "DreampipeOutput.InputLocationSawmillLog.LogsProxyReadInfo",
            "properties": {
                "logsProxySpec": {
                    "items": {
                        "$ref": "DreampipeOutput.InputLocationSawmillLogLogsProxyReadInfo.LogsProxySpec"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "DreampipeOutput.InputLocationSawmillLogLogsProxyReadInfo.LogsProxySpec": {
            "id": "DreampipeOutput.InputLocationSawmillLogLogsProxyReadInfo.LogsProxySpec",
            "properties": {
                "enableDiffLogs": {
                    "type": "boolean"
                },
                "logType": {
                    "type": "string"
                },
                "shard": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "sourceType": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeOutput.OutputLocation.File": {
            "id": "DreampipeOutput.OutputLocation.File",
            "properties": {
                "format": {
                    "description": "The format of this output (e.g. recordio, columnio).",
                    "type": "string"
                },
                "location": {
                    "description": "The same location as in OutputDef.location but with all variables\nexpanded (see http://g3doc/pipeline/dreampipe/g3doc/variables.md).",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeServer..BackfillInfo": {
            "description": "BackfillInfo contains the data pertaining to a backfill.",
            "id": "DreampipeServer..BackfillInfo",
            "properties": {
                "backfillKey": {
                    "$ref": "DreampipeBackfill..BackfillKey",
                    "description": "Unique identifier of the backfill."
                },
                "status": {
                    "description": "Current status of the backfill.",
                    "enum": [
                        "ACTIVE",
                        "DISABLED",
                        "PAUSED"
                    ],
                    "enumDescriptions": [
                        "Active backfill will cause unfulfilled instances to get recomputed and also\nto be handled as specified by their 'Valid' and 'Processable' flags. Active\nbackfill can still have some of its outputs paused as specified by the\n'Active' flag of respective outputs.",
                        "Disabled backfill has no affect on computation of pending and completed\ninstances. Disabled backfills are not loaded into graph (RAM).",
                        "Paused backfill will not cause unfulfilled instances to get recomputed, but\nthey would be handled as specified by their 'Valid' and 'Processable'\nflags."
                    ],
                    "type": "string"
                },
                "versions": {
                    "description": "All versions of the backfill in descending version_id order. The first\n(i.e. the newest) version is the one that takes effect.",
                    "items": {
                        "$ref": "DreampipeBackfill..BackfillVersion"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "DreampipeServer..BulkOutputLookup": {
            "id": "DreampipeServer..BulkOutputLookup",
            "properties": {
                "outputLookup": {
                    "description": "Specify any number of outputs to be looked up.",
                    "items": {
                        "$ref": "DreampipeServer..OutputLookup"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "DreampipeServer..BulkOutputLookupResponse": {
            "id": "DreampipeServer..BulkOutputLookupResponse",
            "properties": {
                "response": {
                    "description": "The responses are identified by index, i.e. response at any index\ncorresponds to the request at the same index.",
                    "items": {
                        "$ref": "DreampipeServer..OutputLookupResponse"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "DreampipeServer..CreateBackfillVersionRequest": {
            "id": "DreampipeServer..CreateBackfillVersionRequest",
            "properties": {
                "backfillId": {
                    "description": "Unique identifier of a backfill, if specified this will create a new\nversion for the specified backfill. Otherwise, a new backfill will be\ncreated.",
                    "format": "int64",
                    "type": "string"
                },
                "description": {
                    "description": "Description for this backfill version.",
                    "type": "string"
                },
                "mandateId": {
                    "description": "Id of the mandate this backfill version refers to. Backfill may only\ncontain outputs that are executed by the specified mandate (i.e. they have\nthe current definition set in the mandate). Propagation of outputs will be\ndone per dependencies specified in their current definitions. If this field\nis not specified, the backfill refers to the default mandate.",
                    "type": "string"
                },
                "outputs": {
                    "description": "Outputs included in this backfill version.",
                    "items": {
                        "$ref": "DreampipeBackfill..Output"
                    },
                    "type": "array"
                },
                "propagateOutputs": {
                    "description": "Names of outputs from the 'outputs' field that will have their descendants\nautomatically added to the backfill. This propagation stops when an output\nspecified in the 'prune_outputs' field is encountered. All outputs\nspecified in the 'propagate_outputs' field need to be included in the\n'outputs' field as well.\n\nFormally, if A={a1,...,am} are the outputs to propagate, and B={b1,...,bn}\nare the outputs to prune, output x will automatically be added to the\nbackfill if there exists a path in the dependency graph of the outputs\ns->o1->...->ok->x, such that s is an element of A, and none of the outputs\no1,...,ok,x is an element of B. Assume we have the following dependency\ngraph of the outputs:\n\n       -> b  ->  c\n     /             \\\n   a - -> d  ->  e  => f\n\nwith the outputs to propagate A={a}, and the outputs to prune B={b}. The\nfollowing outputs will be included in this backfill: {a, d, e, f}. Output a\nis the root of this backfill, only those instances of d, e and f that are\ndescendants of recomputed instances of a will get recomputed.\n\nAutomatically added outputs will have an empty 'criteria' field. This means\nthat only those instances of these outputs whose inputs are in the backfill\nas well will be backfilled. These instances will be considered fulfilled\nonce they get recomputed based on fulfilled inputs.\n\nAll execution properties ('output_valid', 'output_processable', 'active')\nof automatically added outputs will be set to true.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "pruneOutputs": {
                    "description": "Names of outputs for which the propagation will be halted. Outputs\nspecified in the 'prune_outputs' field must not be specified in the\n'outputs' field.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "DreampipeServer..CreateBackfillVersionResponse": {
            "id": "DreampipeServer..CreateBackfillVersionResponse",
            "properties": {
                "backfillVersionKey": {
                    "$ref": "DreampipeBackfill..BackfillVersionKey",
                    "description": "Unique identifier of the backfill version that was created."
                }
            },
            "type": "object"
        },
        "DreampipeServer..ListBackfillsResponse": {
            "id": "DreampipeServer..ListBackfillsResponse",
            "properties": {
                "backfills": {
                    "description": "Information about backfills satisfying the search criteria. The returned\nbackfills are sorted by their creation time (i.e. the backfill_id) so that\nthe newer backfills come first.",
                    "items": {
                        "$ref": "DreampipeServer..BackfillInfo"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "DreampipeServer..ListMandatesResponse": {
            "id": "DreampipeServer..ListMandatesResponse",
            "properties": {
                "mandates": {
                    "description": "List of mandates satisfying the filter in the request.",
                    "items": {
                        "$ref": "DreampipeServer..MandateInfo"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "DreampipeServer..MandateInfo": {
            "description": "MandateInfo holds the data about a single mandate.",
            "id": "DreampipeServer..MandateInfo",
            "properties": {
                "aclInheritanceRestricted": {
                    "enumDescriptions": [
                        "",
                        "This role can only be set for a domain target. Following RPCs may be\ninvoked by domain readers:\n  - ListBackfills\n  - ListPrincipals\n  - GetDomainInfo\n  - QueryPendingDeletions",
                        "This role can only be set for a domain target. Following RPCs may be\ninvoked by domain writers:\n  - GrantAccess\n  - RevokeAccess\n  - CreateBackfillVersion\n  - ListBackfills\n  - SetBackfillStatus\n  - ListPrincipals\n  - BulkInsertOrUpdateOutput\n  - PushRetentionPolicies // TODO(b/66157858)\n  - QueryPendingDeletions\n  - ReportDeleted\n  - GetDomainInfo",
                        "This role can be defined for both a domain and a mandate target. Following\nRPCs may be invoked by mandate readers:\n  - ListMandates\n  - ListPrincipals\nNOTE: Mandate feature has not yet been launched, this role should not be\nused.",
                        "This role can be defined for both a domain and a mandate target. Following\nRPCs may be invoked by mandate writers:\n  - CreateMandateVersion\n  - ListMandates\n  - GrantAccess\n  - RevokeAccess\n  - ListPrincipals\nNOTE: Mandate feature has not yet been launched, this role should not be\nused.",
                        "This role can only be set for a domain target. Following RPCs may be\ninvoked by backfill readers:\n  - ListBackfills",
                        "This role can only be set for a domain target. Following RPCs may be\ninvoked by backfill writers:\n  - CreateBackfillVersion\n  - ListBackfills\n  - SetBackfillStatus",
                        "This role can only be set for a domain target. Following RPCs may be\ninvoked by retention reader:\n  - ReadRetention",
                        "This role can only be set for a domain target. Following RPCs may be\ninvoked by retention writers:\n  - PushRetention\n  - ReadRetention",
                        "This role can only be set for a launcher_pool target. Following RPCs may\nbe invoked by launcher pool writers:\n - QueryActiveRunners",
                        "This role can only be set for a domain target. Following RPCs may be\ninvoked by output readers:\n  - BulkLookupOutputs",
                        "This role can only be set for a domain target. Following RPCs may be\ninvoked by output writers:\n  - BulkLookupOutputs\n  - DeleteOutputs\n  - BulkInsertOrUpdateOutput",
                        "This role can be set for a domain and a mandate target. Following RPCs\nmay be invoked by instance reader:\n  - QueryPendingInstances (without claiming the lock)\n  - QueryCompletedInstances",
                        "This role can be set for a domain and a mandate target. Following RPCs\nmay be invoked by exec attempts writer:\n  - OverrideAttemptCount",
                        "This role can be set for a domain and a mandate target. Following RPCs\nmay be invoked by scheduling status reader:\n  - GetOutputDefSchedulingStatus",
                        "This role can be set for a domain and a mandate target. Following RPCs\nmay be invoked by scheduling status writer:\n  - GetOutputDefSchedulingStatus\n  - SetOutputDefSchedulingStatus"
                    ],
                    "items": {
                        "enum": [
                            "ROLE_UNKNOWN",
                            "ROLE_DOMAIN_READER",
                            "ROLE_DOMAIN_WRITER",
                            "ROLE_MANDATE_READER",
                            "ROLE_MANDATE_WRITER",
                            "ROLE_BACKFILL_READER",
                            "ROLE_BACKFILL_WRITER",
                            "ROLE_RETENTION_READER",
                            "ROLE_RETENTION_WRITER",
                            "ROLE_LAUNCHER_POOL_WRITER",
                            "ROLE_OUTPUT_READER",
                            "ROLE_OUTPUT_WRITER",
                            "ROLE_INSTANCE_READER",
                            "ROLE_EXEC_ATTEMPTS_WRITER",
                            "ROLE_SCHEDULING_STATUS_READER",
                            "ROLE_SCHEDULING_STATUS_WRITER"
                        ],
                        "type": "string"
                    },
                    "type": "array"
                },
                "mandateKey": {
                    "$ref": "DreampipeMandate..MandateKey",
                    "description": "Unique identifier of a mandate."
                },
                "status": {
                    "description": "Current status of this mandate.",
                    "enum": [
                        "STATUS_UNKNOWN",
                        "STATUS_ACTIVE",
                        "STATUS_DISABLED"
                    ],
                    "enumDescriptions": [
                        "",
                        "",
                        ""
                    ],
                    "type": "string"
                },
                "versions": {
                    "description": "All versions of the mandate in descending version_id order. The first (i.e.\nthe newest) version is the one that takes effect.",
                    "items": {
                        "$ref": "DreampipeMandate..MandateVersion"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "DreampipeServer..OutputLookup": {
            "id": "DreampipeServer..OutputLookup",
            "properties": {
                "domain": {
                    "description": "The domain of the output that you're querying.",
                    "type": "string"
                },
                "indexes": {
                    "description": "The indices of OutputDefs that you want returned. If you want all\nOutputDefs, leave empty.\n\nIndexing uses the python convention: -1 is most recent, -2 the one before\nthat, 0 is first, etc.",
                    "items": {
                        "format": "int32",
                        "type": "integer"
                    },
                    "type": "array"
                },
                "name": {
                    "description": "The name of the OutputDef that you're querying. If the output does not\nexist, an error will be returned.",
                    "type": "string"
                },
                "timestamps": {
                    "description": "The timestamps of OutputDefs that you want returned. If you want all\nOutputDefs, leave empty.",
                    "items": {
                        "format": "int64",
                        "type": "string"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "DreampipeServer..OutputLookupResponse": {
            "id": "DreampipeServer..OutputLookupResponse",
            "properties": {
                "version": {
                    "description": "Version contains an entry for each of the OutputDefs requested in the\nOutputLookup.\nIf an OutputLookup requests an OutputDef that does not exist, the\ncorresponding slot will be empty;\nuse version[i].definition.timestamp == 0 to recognize non-existing\nversions.",
                    "items": {
                        "$ref": "DreampipeServer.OutputLookupResponse.FullOutputDef"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "DreampipeServer..SetBackfillStatusResponse": {
            "id": "DreampipeServer..SetBackfillStatusResponse",
            "properties": {},
            "type": "object"
        },
        "DreampipeServer.OutputLookupResponse.FullOutputDef": {
            "id": "DreampipeServer.OutputLookupResponse.FullOutputDef",
            "properties": {
                "definition": {
                    "$ref": "DreampipeDefinition..OutputDef",
                    "description": "The output definition."
                }
            },
            "type": "object"
        },
        "DreampipeTime..ConsecutiveInstancesTime": {
            "description": "The ConsecutiveInstancesTime identifies the time of an instance that is\neither the first or the last instance in a block of consecutive available\ninstances. In other words, it identifies the time when the instantiation\nstarted/stopped failing.\n\nTo identify a block of consecutive available instances, we look at the stream\nof dates when the outputDef should have been instantiated and count the\nconsecutive dates/datetimes when the instances were successfully computed.\nOnce the counter is equal to or bigger than block_size, then we can consider\nthat range to be a block of consecutive available instances.\n\nNote that the block_size is expressed in terms of consecutive instances in\nthe instantiation schedule. For example, if the instantiation schedule is\nweekly and block_size = 2, then we are looking for at least two instances\nthat are one week apart.\n\nIn case of multiple blocks, the block_selector identifies which of them to\nchoose, either the earliest instantiation date or the latest one. The\nreference_time_selector has the same role but within the block range. It\nselects either the first or the last instance of the block.\n\nThe followings are examples of what the reference time is identified as,\ngiven different selectors. For this, we consider the instantiation of an\noutputDef over the first 15 days of a month. 'X' marks the dates with\nsuccessful instantiation and '.' marks the opposite:\n1   2   3   4   5   6   7   8   9   10   11   12   13   14   15\n.   X   .   X   X   X   .   X   X   X    X    X    .    .    .\n\n    block_size = 3\n    block_selector = EARLIEST          => 4th\n    reference_time_selector = EARLIEST\n\n    block_size = 3\n    block_selector = LATEST            => 8th\n    reference_time_selector = EARLIEST\n\n    block_size = 3\n    block_selector = LATEST            => 12th\n    reference_time_selector = LATEST",
            "id": "DreampipeTime..ConsecutiveInstancesTime",
            "properties": {
                "blockSelector": {
                    "description": "If there are multiple blocks of consecutive instances, defines which one\nto choose. If not set, it defaults to SELECTOR_LATEST.",
                    "enum": [
                        "SELECTOR_LATEST",
                        "SELECTOR_EARLIEST"
                    ],
                    "enumDescriptions": [
                        "",
                        ""
                    ],
                    "type": "string"
                },
                "blockSize": {
                    "format": "int32",
                    "type": "integer"
                },
                "referenceTimeSelector": {
                    "description": "Indicates whether the reference_time should be the beginning or the end of\nthe selected block. If not set, it defaults to SELECTOR_LATEST.",
                    "enum": [
                        "SELECTOR_LATEST",
                        "SELECTOR_EARLIEST"
                    ],
                    "enumDescriptions": [
                        "",
                        ""
                    ],
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeTime..CurrentTime": {
            "description": "The reference time of a CurrentTime is the current time.\n\nApplies to: InputDef, SchedulingTimeConstraint",
            "id": "DreampipeTime..CurrentTime",
            "properties": {},
            "type": "object"
        },
        "DreampipeTime..FixedDateTime": {
            "description": "The reference time of a FixedDateTime constraint is a fixed point in time.\n\nApplies to: InputDef, SchedulingTimeConstraint",
            "id": "DreampipeTime..FixedDateTime",
            "properties": {
                "fixedDateTime": {
                    "description": "Use the given reference date-time as the reference time.",
                    "type": "string"
                },
                "fixedTimezone": {
                    "description": "Timezone for fixed_date_time; if not set, America/Los_Angeles is implied.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DreampipeTime..InstanceTime": {
            "description": "The reference time of InstanceTime is the date-time parameter of the\ninstance. Only applies to time-based inputs.\n\nApplies to: InputDef",
            "id": "DreampipeTime..InstanceTime",
            "properties": {},
            "type": "object"
        },
        "DreampipeTime..LastComputableOrExisting": {
            "description": "The reference time of a LastComputableOrExisting is the time of the last\ninstance which either:\n  * does not exist, and all inputs are available (is \"computable\"), or\n  * already exists (in which case, it doesn't matter if its inputs are\n    still available).\nIf no such instance exists, the period doesn't exist.\n\nApplies to: SchedulingTimeConstraint",
            "id": "DreampipeTime..LastComputableOrExisting",
            "properties": {},
            "type": "object"
        },
        "DreampipeTime..StartDateTime": {
            "description": "The reference time of a StartDateTime is taken from the effective\nstart date time of the output.\n\nFor the requests not using mandates that means\nOutputDef.instantiation.periodic.start_date_time of the latest\nOutputDef.\n\nFor the requests using mandate, this uses\ndreampipe.mandate.Output.instance_selector.date_time_range.start of output\nin the respective mandate.\n\nApplies to: SchedulingTimeConstraint",
            "id": "DreampipeTime..StartDateTime",
            "properties": {},
            "type": "object"
        },
        "DreampipeTime..TimeSchedule": {
            "description": "TimeSchedule defines a sequence of timestamps in relation to a given\ninstance timestamp.\n\nNote that some days are 23 and 25 hours long due to DST changes.\nThese depend on the timezone in question, which in turn depends on the\ninput. For Sawmill inputs, it's always America/Los_Angeles.",
            "id": "DreampipeTime..TimeSchedule",
            "properties": {
                "enumerated": {
                    "items": {
                        "$ref": "DreampipeTime.TimeSchedule.PointInTime"
                    },
                    "type": "array"
                },
                "periodic": {
                    "items": {
                        "$ref": "DreampipeTime.TimeSchedule.Periodic"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "DreampipeTime.TimeSchedule.Periodic": {
            "description": "Periodic defines a series of timestamps on a regular schedule.\n\nA typical way to use a Periodic TimeSchedule is with data sources where\npart of the data may appear later, such as Sawmill logs. In Sawmill, while\nmost events for most logs arrive within minutes to hours after the end of\nthe logging day, events are accepted within the 14-day collection window.\n\nIn this case, you can define the first computation when you have enough\ndata for initial results, then use recomputation to make sure the data\nwill eventually contain all events.",
            "id": "DreampipeTime.TimeSchedule.Periodic",
            "properties": {
                "end": {
                    "$ref": "DreampipeTime.TimeSchedule.PointInTime"
                },
                "period": {
                    "format": "int32",
                    "type": "integer"
                },
                "periodUnit": {
                    "enum": [
                        "PERIOD_UNKNOWN",
                        "PERIOD_SECOND",
                        "PERIOD_CALENDAR_DAY",
                        "PERIOD_CALENDAR_MONTH"
                    ],
                    "enumDescriptions": [
                        "Not to be used. See go/protodosdonts.",
                        "Second as defined by SI.",
                        "Day defines a calendar day periodicity. Most days are 24 hours long,\nbut around daylight savings times they may be 23 or 25 hours.",
                        "Calendar month periodicity."
                    ],
                    "type": "string"
                },
                "start": {
                    "$ref": "DreampipeTime.TimeSchedule.PointInTime",
                    "description": "The schedule is defined as the sequence ts(i), with ts defined as:\n\n  ts(i) = start + i * period * period_unit\n\nfor all i >= 0, as long as ts(i) < end.\n\n(I.e. start is inclusive, end is exclusive limit.)"
                }
            },
            "type": "object"
        },
        "DreampipeTime.TimeSchedule.PointInTime": {
            "description": "NOTE: for Sawmill logs, this instantiation happens at the *start* of\nthe logging day. So you almost always want a TimeSchedule.\n\nTo process a day's log, a typical choice is to use e.g. to wait until at\nleast 3 hours after the end of the logging day:\n\n  days = 1, seconds = 3 * 3600\n\nPointInTime describes a timestamp in relation to the instantiation\ntime of the instance.",
            "id": "DreampipeTime.TimeSchedule.PointInTime",
            "properties": {
                "days": {
                    "description": "The point in time is defined as instance_time + days + seconds.",
                    "format": "int32",
                    "type": "integer"
                },
                "seconds": {
                    "format": "int32",
                    "type": "integer"
                }
            },
            "type": "object"
        },
        "Edge": {
            "id": "Edge",
            "properties": {
                "data": {
                    "$ref": "EdgeData"
                },
                "destId": {
                    "type": "string"
                },
                "srcId": {
                    "description": "dest_id node depends on src_id node as described in its input definition.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "EdgeData": {
            "description": "TODO(mpinzaru) EdgeData is work in progress.",
            "id": "EdgeData",
            "properties": {
                "inputDef": {
                    "$ref": "DreampipeDefinition..InputDef",
                    "description": "Input definition of the input group."
                }
            },
            "type": "object"
        },
        "ExecutionHistoryEntry": {
            "id": "ExecutionHistoryEntry",
            "properties": {
                "attemptCountOverride": {
                    "format": "int32",
                    "type": "integer"
                },
                "completionTime": {
                    "format": "int64",
                    "type": "string"
                },
                "instanceId": {
                    "type": "string"
                },
                "isIgnored": {
                    "type": "boolean"
                },
                "lockId": {
                    "format": "int64",
                    "type": "string"
                },
                "lockValidUntil": {
                    "format": "int64",
                    "type": "string"
                },
                "runInfo": {
                    "$ref": "RunInfo"
                },
                "status": {
                    "enum": [
                        "UNKNOWN",
                        "RUNNING",
                        "SUCCESSFUL",
                        "FAILED",
                        "OVERRIDE"
                    ],
                    "enumDescriptions": [
                        "",
                        "",
                        "",
                        "",
                        ""
                    ],
                    "type": "string"
                }
            },
            "type": "object"
        },
        "ExecutionHistoryResponse": {
            "id": "ExecutionHistoryResponse",
            "properties": {
                "domain": {
                    "type": "string"
                },
                "history": {
                    "items": {
                        "$ref": "ExecutionHistoryEntry"
                    },
                    "type": "array"
                },
                "name": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "Explicit": {
            "description": "Specifies minimum time between STARTS of two retries as follows:\nFor n-th failed attempt we use (n-1)st minimum delay_seconds and want allow\nnext retry unless at least minimum_delay_seconds passed since the start\nof the last attempt.\nIf there aren't enough entries in the minimum_delay_seconds, the last delay\nis applied for the remaining retry attempts.",
            "id": "Explicit",
            "properties": {
                "minimumDelaySeconds": {
                    "items": {
                        "format": "int64",
                        "type": "string"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "Factor": {
            "id": "Factor",
            "properties": {
                "base": {
                    "format": "double",
                    "type": "number"
                },
                "common": {
                    "format": "double",
                    "type": "number"
                },
                "groupOnly": {
                    "format": "double",
                    "type": "number"
                }
            },
            "type": "object"
        },
        "FutureBorgJobLocation": {
            "description": "Information about a borg job that will be started in the future.\n\nSimilar to BorgTaskLocation, but can be known before the job is actually\nstarted.\n\nNote that this is ambiguous, since several distinct jobs may have these\nproperties at different points in time.",
            "id": "FutureBorgJobLocation",
            "properties": {
                "borgCell": {
                    "description": "Expected job location and names.",
                    "type": "string"
                },
                "borgJobName": {
                    "type": "string"
                },
                "borgUser": {
                    "type": "string"
                },
                "borgcfgFile": {
                    "description": "The borg config file and vars that will be used to start the job.",
                    "type": "string"
                },
                "borgcfgVars": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "createdAfterTimestampSec": {
                    "description": "The job will have been created after this time.",
                    "format": "int64",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "GetComputationGraphResponse": {
            "id": "GetComputationGraphResponse",
            "properties": {
                "analysisResult": {
                    "items": {
                        "$ref": "AnalysisResult"
                    },
                    "type": "array"
                },
                "computationNodes": {
                    "items": {
                        "$ref": "DreampipeInternalComputation..Node"
                    },
                    "type": "array"
                },
                "edges": {
                    "items": {
                        "$ref": "Edge"
                    },
                    "type": "array"
                },
                "nodes": {
                    "items": {
                        "$ref": "Node"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "InnerStrategy": {
            "id": "InnerStrategy",
            "properties": {
                "order": {
                    "description": "By default, this is set to COMPUTE_OLDEST_FIRST.",
                    "enum": [
                        "COMPUTE_OLDEST_FIRST",
                        "COMPUTE_NEWEST_FIRST"
                    ],
                    "enumDescriptions": [
                        "",
                        ""
                    ],
                    "type": "string"
                },
                "timeConstraint": {
                    "$ref": "SchedulingTimeConstraint",
                    "description": "Defines a time period constraint for scheduling.\nIf set, instances that are outside the time period are not considered\nfor computation.\nIf not set, then no time restriction is applied and all instances are\nconsidered for computation."
                },
                "type": {
                    "description": "At least one value must be specified for this field. Otherwise, the\nstrategy is not valid.",
                    "enumDescriptions": [
                        "ComputationType is used to classify the instances by the scheduling\nstrategy. For more details, see\nhttp://cs/&q=symbol:dreampipe.scheduling.SchedulingStrategy",
                        "",
                        "",
                        ""
                    ],
                    "items": {
                        "enum": [
                            "COMPUTATION_TYPE_UNKNOWN",
                            "COMPUTATION_TYPE_FIRST_COMPUTATION",
                            "COMPUTATION_TYPE_MANUAL_BACKFILL",
                            "COMPUTATION_TYPE_RECOMPUTATION"
                        ],
                        "type": "string"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "InputRequirement": {
            "id": "InputRequirement",
            "properties": {
                "clusterLocality": {
                    "description": "The cluster where the input should be located for the input to be\nschedulable for computation. Note that this is always in terms\nof the cluster, not e.g. bigtable cell or colossus cell\n(i.e. qa instead of mix-qa or qa-d).",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "inputLocality": {
                    "description": "Determines how cluster_locality should be applied.",
                    "enum": [
                        "INPUT_LOCALITY_UNKNOWN",
                        "INPUT_LOCALITY_HARD",
                        "INPUT_LOCALITY_CELL_FAILOVER"
                    ],
                    "enumDescriptions": [
                        "Not to be used. See go/protodosdonts.",
                        "Hard locality means that we will only return inputs that fulfill the\nlocality requirements of the InputRequirement message.",
                        "Cluster failover locality means that Dreampipe will only failover to other\nclusters when all clusters in InputRequirement.cluster_locality are\nunavailable due to a PCR.\n\nNote that unavailability of inputs in the cluster doesn't matter, i.e.\nwe won't read from the failover cluster simply because input isn't\navailable in the primary clusters. The cluster (or the service cell) needs\nto be down for this setting to take effect."
                    ],
                    "type": "string"
                },
                "name": {
                    "description": "The InputDef.name of the input that this message is concerned about.\n\nNote: this name is relative to the OutputDef we're considering. If the\nOutputDef doesn't have an input with this name, it's ignored. If multiple\nOutputDefs have an input with the same name, the requirement is applied\nto all those OutputDefs. This is a feature, not bug: it lets you share\nthe InputRequirement across many OutputDefs, if you choose the name in a\nsuitable way.",
                    "type": "string"
                },
                "sawmillInput": {
                    "$ref": "SawmillInput"
                }
            },
            "type": "object"
        },
        "InputSharingOptions": {
            "description": "In this file, we use these definitions:\n\n  |x| is the size of the files in a set of files (This is an abuse of the\n      set theory notation, where |.| indicates the cardinality of the set.);\n  B is the set of files in the base group;\n  C is the set of files already selected (i.e. all current groups); and\n  x is the set of files in the current group under consideration.\n\nWe combine this with the usual set theory notation, therefore, for example:\n\n  |x \u2229 B| is the size of files common to current group and base group\n  |x \u2216 B| is the size of the files in current group but not in base group",
            "id": "InputSharingOptions",
            "properties": {
                "maxDeduplicatedInputs": {
                    "description": "We also want to include a term which prevents excessive sharing. This\nusually causes problems because of too much I/O for the intermediate\ncomputations or the final outputs.\n\nOne way to approach this estimation is by assuming that each computation\nreading input group x produces output whose size is assumed to be\nproportional to |x|, and we don't want a single run to produce too much\noutput.\n\nHowever, for simplicity, we express this limitation on the total number\nof input read. Here we ignore the effects of deduplication, i.e. if the\ninput group x is used by count(x) computations, we also include it\ncount(x) times in the final output. The definition is as follows: if\nfor a computation group x:\n\n \u2211(|c| \u00d7 count(c)) + |x| \u00d7 count(x) \u2265 max_deduplicated_inputs \u00d7 |B|,\n\nwhere\n\n c          iterates over input group,\n the sum \u2211  is assumed to go over all input groups c which have\n            already been selected, and\n count(.)   counts how many pending instances read that input group,\n\nthen we reject adding the current input x to the computation. Actually, we\nwill be more fine-grained than that, and only select as many instances\nas we can (less than count(x)) from x to keep the total inputs below\nlimits.\n\nExample: if\n\n   max_deduplicated_inputs = 20.0,\n\nwe will read no more than 20 times the size of B due to input sharing,\n(ignoring deduplication). For example, if all instances need just the\nset B for input, then we read no more than 20 instances in a single\ncomputation.",
                    "format": "double",
                    "type": "number"
                },
                "maxSharingLimit": {
                    "description": "To prevent penalizing the base group by excessive sharing, we want to\nlimit the total amount of extra files read. In units of |B|. If adding\nthe current group x to the computation would cause this expression to\nbecome true:\n\n |x \u222a C| \u2265 max_sharing_limit \u00d7 |B|,\n\nthen we won't add x. Values below 1.0 don't make sense and are rejected.\nExample:\n\n  max_sharing_limit = 1.3  // Read no more than 30% extra in a single run\n                           // due to input sharing.",
                    "format": "double",
                    "type": "number"
                },
                "minOverlapLimit": {
                    "description": "Conversely, we also want to prevent adding a sharing group if its overlap\nis too small. For example, if a computation is only reading 10GB of common\ndata, it may not make sense to couple it with the fate of a computation\nthat is reading 10TB data in total. In units of |B|, but expressed in terms\nof total overlap with *any* input that has already been chosen for reading.\nIn other words, if for a candidate group x:\n\n |x \u2229 C| < min_overlap_limit \u00d7 |B|,\n\nthen we won't add x to the computation now (but this may change if C\nchanges). Example:\n\n  min_overlap_limit = 0.1  // Don't include this in a run unless we overlap\n                           // with at least 10% of the inputs.",
                    "format": "double",
                    "type": "number"
                },
                "overlapMultiplier": {
                    "$ref": "Factor",
                    "description": "Define the overlap score for a group considered for sharing. The score is\ndefined as:\n\n base \u00d7 |B| + common \u00d7 |x \u2229 B| + group_only \u00d7 |x \u2216 B|.\n\nThe highest score is considered eligible for sharing. Negative scores are\nnot considered.\n\nExample:\n  common = 1.0       // favor overlap |x \u2229 B|\n  group_only = -2.0  // penalize |x \u2216 B|"
                }
            },
            "type": "object"
        },
        "InstanceStatus": {
            "id": "InstanceStatus",
            "properties": {
                "availableCount": {
                    "description": "The number of versions currently available (excluding deleted), which\nfulfill the specified mandate.",
                    "format": "int32",
                    "type": "integer"
                },
                "availableTimestamp": {
                    "description": "The start time of the computation that produced the most recent available\ndata for this instance.",
                    "format": "google-datetime",
                    "type": "string"
                },
                "backfillIds": {
                    "description": "The IDs of any outstanding backfills for this OutputInstance.",
                    "items": {
                        "format": "int64",
                        "type": "string"
                    },
                    "type": "array"
                },
                "dataStatus": {
                    "enum": [
                        "UNKNOWN_DATA_STATUS",
                        "MISSING",
                        "AVAILABLE",
                        "DELETED",
                        "INVALIDATED"
                    ],
                    "enumDescriptions": [
                        "",
                        "No data is available yet. Most likely a data dependency.",
                        "At least one version is available.",
                        "Data was calculated, but is past the retention period.",
                        "A backfill request marked the data as invalid."
                    ],
                    "type": "string"
                },
                "healthStatus": {
                    "enum": [
                        "UNKNOWN_HEALTH_STATUS",
                        "HEALTHY",
                        "UNHEALTHY",
                        "FAILED"
                    ],
                    "enumDescriptions": [
                        "",
                        "All attempts to generate this data were successful.",
                        "Some attempts to generate this data were unsuccessful.",
                        "All attempts to generate this data were unsuccessful."
                    ],
                    "type": "string"
                },
                "instanceId": {
                    "description": "Canonical ID for this instance.",
                    "type": "string"
                },
                "lastAttemptTimestamp": {
                    "description": "The start timestamp of the latest attempt to compute the latest version.\nThe execution attempt may still be running.",
                    "format": "google-datetime",
                    "type": "string"
                },
                "latestAttempts": {
                    "description": "Number of successive attempts since the last successful attempt. May have\nbeen reset by an override and includes currently running executions.",
                    "format": "int32",
                    "type": "integer"
                },
                "pendingReason": {
                    "enum": [
                        "UNKNOWN_PENDING_REASON",
                        "FRONTFILL",
                        "BACKFILL",
                        "RECOMPUTATION"
                    ],
                    "enumDescriptions": [
                        "",
                        "",
                        "",
                        ""
                    ],
                    "type": "string"
                },
                "schedulingStatus": {
                    "enum": [
                        "UNKNOWN_SCHEDULING_STATUS",
                        "BLOCKED",
                        "PENDING",
                        "RUNNING",
                        "COMPLETE"
                    ],
                    "enumDescriptions": [
                        "",
                        "A dependency is missing, so no computation can run.",
                        "A (re)computation is required.",
                        "A (re)computation is in progress.",
                        "No computation is required."
                    ],
                    "type": "string"
                },
                "versionCount": {
                    "description": "The number of versions generated for this instance, which fulfill the\nspecified mandate.",
                    "format": "int32",
                    "type": "integer"
                }
            },
            "type": "object"
        },
        "InstanceToComplete": {
            "description": "The location of an instance / execution attempt to be marked as complete.\n\nWARNING: It is the caller's responsibility that to ensure that the output\nlocation of the execution attempt is valid. It should either point to valid\nfiles, or the downstream computation must be okay with missing data.",
            "id": "InstanceToComplete",
            "properties": {
                "domain": {
                    "type": "string"
                },
                "instanceId": {
                    "description": "Instance ID is an internal implementation detail, which should not be\nrelied on.",
                    "type": "string"
                },
                "lockId": {
                    "format": "int64",
                    "type": "string"
                },
                "mandateId": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "LauncherPool": {
            "id": "LauncherPool",
            "properties": {
                "poolId": {
                    "description": "The ID of this launcher pool. Corresponds to the pool_id field of\ndreampipe.launcher.LauncherPool.",
                    "type": "string"
                },
                "queues": {
                    "items": {
                        "$ref": "Queue"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "LauncherQueue": {
            "id": "LauncherQueue",
            "properties": {
                "borgTaskInfo": {
                    "items": {
                        "$ref": "BorgTaskInfo"
                    },
                    "type": "array"
                },
                "queue": {
                    "$ref": "Queue"
                }
            },
            "type": "object"
        },
        "ListComputationGraphsResponse": {
            "id": "ListComputationGraphsResponse",
            "properties": {
                "isPending": {
                    "description": "Set true if the instance is triggered for recomputation.",
                    "type": "boolean"
                },
                "timestamps": {
                    "description": "Timestamp of computation graph snapshot stored in Refinery.",
                    "items": {
                        "$ref": "DelayedTimestamp"
                    },
                    "type": "array"
                },
                "unfulfilledBackfills": {
                    "description": "Backfills for which this instance has no fulfilled versions.",
                    "items": {
                        "$ref": "UnfulfilledBackfillInfo"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "ListDeploymentsResponse": {
            "id": "ListDeploymentsResponse",
            "properties": {
                "deployments": {
                    "items": {
                        "$ref": "DeploymentInfo"
                    },
                    "type": "array"
                },
                "preferredDeployment": {
                    "description": "If multiple deployments are present, the preferred one to use.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "ListDomainsResponse": {
            "id": "ListDomainsResponse",
            "properties": {
                "domains": {
                    "items": {
                        "$ref": "DomainWithDefaultMandate"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "ListInputNotificationEntry": {
            "id": "ListInputNotificationEntry",
            "properties": {
                "name": {
                    "type": "string"
                },
                "notification": {
                    "items": {
                        "$ref": "Notification"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "ListInstanceNotificationEntry": {
            "id": "ListInstanceNotificationEntry",
            "properties": {
                "instanceId": {
                    "type": "string"
                },
                "notification": {
                    "items": {
                        "$ref": "Notification"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "ListInstancesResponse": {
            "id": "ListInstancesResponse",
            "properties": {
                "instances": {
                    "items": {
                        "$ref": "InstanceStatus"
                    },
                    "type": "array"
                },
                "nextPageToken": {
                    "description": "A token to be supplied to the request method to get the next page. This\nshould be treated as an opaque token.",
                    "type": "string"
                },
                "totalSize": {
                    "description": "The total available size of the response, if known.",
                    "format": "int32",
                    "type": "integer"
                }
            },
            "type": "object"
        },
        "ListNotificationsResponse": {
            "description": "List of notifications matching the ListNotificationsRequest.",
            "id": "ListNotificationsResponse",
            "properties": {
                "domain": {
                    "description": "Echo the request settings.",
                    "type": "string"
                },
                "domainNotification": {
                    "items": {
                        "$ref": "Notification"
                    },
                    "type": "array"
                },
                "mandateId": {
                    "type": "string"
                },
                "notification": {
                    "items": {
                        "$ref": "ListOutputNotificationEntry"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "ListOutputNotificationEntry": {
            "id": "ListOutputNotificationEntry",
            "properties": {
                "input": {
                    "items": {
                        "$ref": "ListInputNotificationEntry"
                    },
                    "type": "array"
                },
                "instance": {
                    "items": {
                        "$ref": "ListInstanceNotificationEntry"
                    },
                    "type": "array"
                },
                "output": {
                    "type": "string"
                },
                "outputNotification": {
                    "items": {
                        "$ref": "Notification"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "Lock": {
            "description": "Information about a lock.",
            "id": "Lock",
            "properties": {
                "creationTimeUsec": {
                    "description": "Lock commit timestamp.",
                    "format": "int64",
                    "type": "string"
                },
                "lockInfo": {
                    "$ref": "DreampipeInternalLock..LockInfo"
                }
            },
            "type": "object"
        },
        "LockingStrategy": {
            "description": "LockingStrategy determines how locking or lock affirmation are handled.",
            "id": "LockingStrategy",
            "properties": {
                "key": {
                    "enum": [
                        "UNKNOWN_LOCKING_KEY",
                        "INSTANCE_KEY",
                        "MANDATE_INSTANCE_KEY"
                    ],
                    "enumDescriptions": [
                        "",
                        "Default locking key. This is preferable option for domains which don't use\nmandates. It is based on domain name, output name and instance id.\n\nIt prevents two parallel computations of the same specific instance (even\nif the inputs/output version would be different).",
                        "Preferable option for domains using mandates. It is based on domain\nname, output name, instance id and mandate id.\n\nIt prevents two parallel computations of the same specific instance within\nmandate (even if the inputs/output version would be different) but allows\nparallel computations of the same instance within different mandates."
                    ],
                    "type": "string"
                },
                "leaseTimeoutSeconds": {
                    "description": "The lease_timeout_seconds specifies the time from current time when the\nlock will be considered expired. This value is used in both AcquireLock\nand ExtendLock calls. If an ExtendLock call is made while the lock is\nstill held, the lease will be extended until the new expiry period.\n(Note that it may be possible to recover and extend the lock even after\nexpiration, if nobody has acquired locks on the instances in the meanwhile.\n\nThis protocol provides two basic approaches for locking:\n\n1) If you want to retry failed/abandoned computations as quickly as\n   possible, set lease_timeout_seconds to a relatively low value\n   (e.g. 300s) in AcquireLock, then keep extending it using the\n   ExtendLock call with a similar timeout before expiry.\n\n2) If you don't want to extend the lock and don't care about quick\n   retries, set lease_timeout_seconds to a value that is longer than\n   the longest expected running time of your computation in AcquireLock.\n   There's no need to call ExtendLock.",
                    "format": "int64",
                    "type": "string"
                },
                "options": {
                    "enum": [
                        "UNKNOWN_LOCKING_OPTION",
                        "STEAL_LOCKS",
                        "STEAL_NEWER_LOCKS",
                        "REQUIRE_ALL_LOCKS",
                        "REQUIRE_SOME_LOCKS",
                        "REQUIRE_NO_LOCKS",
                        "QUERY_IGNORE_LOCKS",
                        "QUERY_UNLOCKED_ONLY"
                    ],
                    "enumDescriptions": [
                        "",
                        "Forcibly acquires all locks specified in the request, breaking any locks\nif necessary. By definition, this call will succeed always as long as\nthe instances exist.\n\nWhen used in LockExtension, this only steals the instances that were\nsuccessfully acquired in the AcquireLock call.",
                        "Same as STEAL_LOCKS, but only break locks whose AcquireLock call happened\nafter the AcquireLock of this call. If the number of locks is zero\neven after extending and stealing locks, this call will fail (i.e. the\nbehavior is similar to REQUIRE_SOME_LOCKS).\n\nNote that this option only really makes sense in an ExtendLock call,\nbecause when executed within AcquireLock this call is by default the last\none. If executed in AcquireLock, the behavior is therefore identical to\nusing REQUIRE_SOME_LOCKS.\n\nWhen used in LockExtension, this only steals the instances that were\nsuccessfully acquired in the AcquireLock call, or successfully extended\nin latest ExtendLock call, whichever came later.",
                        "Requires that all locks specified are held; otherwise, the request\nwill fail.",
                        "Allows some of the locks requested or currently held to be dropped.\nIf all locks are dropped, the request will fail.",
                        "Allows all locks requested to be dropped. Use this if you want to complete\nthe current computation even when the lock is lost; this may be useful to\nnot throw away computation that may already have been mostly completed.\n\nThis call will never fail in an ExtendLock request. However, it doesn't\nmake sense to use REQUIRE_NO_LOCKS in an AcquireLock request; therefore\nDreampipe will instead treat it as REQUIRE_SOME_LOCKS (and the request\nmay consequently fail if no outputs could be locked).\n\n(The reason for this special treatment is that it allows using the same\nLockingStrategy for AcquireLock and ExtendLock calls.)",
                        "Ignore locking when executing the locking query. This is the default.\nOnly available during QueryPendingInstances.",
                        "The returned instances should include only outputs that were not locked at\nthe time of the call, but these instances aren't actually locked.\nOnly available during QueryPendingInstances."
                    ],
                    "type": "string"
                }
            },
            "type": "object"
        },
        "LogInfo": {
            "description": "Non-identifying information about this Log version.",
            "id": "LogInfo",
            "properties": {
                "isMaterialized": {
                    "description": "Whether or not the logs are available as materialized files; false\nindicates that they are generated via on-the-fly join, reading diff logs,\netc.\n\nNote that the default is true because existing metadata in the Dreampipe\nspanner DB, written before non-materialized logs were supported, should\nall be considered as materialized.",
                    "type": "boolean"
                },
                "logUnit": {
                    "description": "A single TrackedInput of type SawmillLog could be an alias that\nresolves to multiple different logs, so this field needs to be\nrepeated.",
                    "items": {
                        "$ref": "LogUnit"
                    },
                    "type": "array"
                },
                "versionKind": {
                    "enum": [
                        "UNKNOWN",
                        "MATERIALIZED",
                        "EXPLICIT_JOIN",
                        "FALLBACK_JOIN",
                        "DIFF_LOGS"
                    ],
                    "enumDescriptions": [
                        "We don't know the version kind.",
                        "The log is fully materialized.",
                        "The log is constructed from an explicit join passed by the user, e.g.\nAdEvents+ConvStats.",
                        "The log is constructed as a fallback on-the-fly join of component logs,\ne.g. AdEventsQueriesContent=AdQueries+AdEvents.  This join is not\nspecified by the user directly.",
                        "The log data is constructed from diff logs, e.g. by passing\nenable_diff_logs=true in F1."
                    ],
                    "type": "string"
                }
            },
            "type": "object"
        },
        "LogUnit": {
            "id": "LogUnit",
            "properties": {
                "joinedLogUnit": {
                    "$ref": "LogUnit",
                    "description": "If the TrackedInput represents a LogsProxy join, this is the LogUnit\non the right side of the join. For example, for the AdQueries+AdEvents\njoin, this field represents AdEvents."
                },
                "logSource": {
                    "type": "string"
                },
                "logType": {
                    "type": "string"
                },
                "logsProxySpec": {
                    "$ref": "LogsProxySpec",
                    "description": "The fully resolved LogsProxy spec to be sent verbatim to LogsProxy when\nreading the log.  If this field is set, you should use it when sending\na request to LogsProxy to read the log.  If the field is not set, you\nshould use information from the parent LogUnit message.\n\nSome examples:\n  -- For log (ads/AdQueries) with join log (processed/ads/AdEvents),\n     logs_proxy_spec will be\n     (processed/ads/AdQueries+AdEventsWithTransform).\n  -- For log (ads/tmp-UnmatchedAdQueries) with no AdEvents join log,\n     logs_proxy_spec will be\n     (processed/ads/tmp-UnmatchedAdQueriesWithTransform)."
                },
                "replicaMetadata": {
                    "$ref": "ClientReplicaMetadata",
                    "description": "Custom metadata defined by processed logs pipelines that is published\nto PaperMill."
                },
                "timestampNs": {
                    "description": "Modification timestamp of this LogUnit, either extracted from the\ntimestamped directory, or from the modification time of the files,\napproximately corresponding the freshness of the data.\nThis does not represent the identity of the entire version\n(which is defined by VersionVars), and can be different from it in\ncase of multiple constituent LogUnits within a single instance\n(e.g. in case of aliases that resolve to more than one LogUnit).\n\nFor diff logs, timestamp_ns is the 'processed until' time.",
                    "format": "uint64",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "LogsProxySpec": {
            "id": "LogsProxySpec",
            "properties": {
                "enableDiffLogs": {
                    "type": "boolean"
                },
                "logSource": {
                    "type": "string"
                },
                "logType": {
                    "type": "string"
                },
                "shard": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "MarkInstancesCompleteRequest": {
            "description": "Request to mark specified instances as completed.",
            "id": "MarkInstancesCompleteRequest",
            "properties": {
                "bugId": {
                    "description": "Bug ID associated with the action of marking these instances as complete.",
                    "format": "int64",
                    "type": "string"
                },
                "instances": {
                    "items": {
                        "$ref": "InstanceToComplete"
                    },
                    "type": "array"
                },
                "note": {
                    "description": "A note describing the reason for marking these instances as complete.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "MarkInstancesCompleteResponse": {
            "id": "MarkInstancesCompleteResponse",
            "properties": {
                "markedCompleteCount": {
                    "description": "Number of instances marked as completed (that weren't already complete).",
                    "format": "int32",
                    "type": "integer"
                },
                "results": {
                    "items": {
                        "$ref": "Result"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "MessageSet": {
            "description": "This is proto2's version of MessageSet.",
            "id": "MessageSet",
            "properties": {},
            "type": "object"
        },
        "MonitoringConfig": {
            "description": "Returns the monitoring configuration for an output.",
            "id": "MonitoringConfig",
            "properties": {
                "value": {
                    "items": {
                        "$ref": "Value"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "NameAndRecentHistory": {
            "id": "NameAndRecentHistory",
            "properties": {
                "entries": {
                    "description": "May be empty.",
                    "items": {
                        "$ref": "RecentHistoryEntry"
                    },
                    "type": "array"
                },
                "outputName": {
                    "description": "required",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "Node": {
            "description": "A graph Node represents a set of computation nodes, aggregated based on\nthe computation node input group they appeared in. We are using the same\nstructure for root node (which is not contained in any input group).",
            "id": "Node",
            "properties": {
                "data": {
                    "$ref": "NodeData"
                },
                "id": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "NodeData": {
            "description": "TODO(mpinzaru) NodeData is work in progress.",
            "id": "NodeData",
            "properties": {
                "computationNodeIndex": {
                    "description": "Index identifies the computation nodes in the computation_nodes array\nthat form a graph node.",
                    "items": {
                        "format": "uint64",
                        "type": "string"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "Notification": {
            "id": "Notification",
            "properties": {
                "creationTimestampUs": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "severity": {
                    "enum": [
                        "SEVERITY_UNKNOWN",
                        "SEVERITY_ERROR",
                        "SEVERITY_WARNING",
                        "SEVERITY_NOTIFICATION"
                    ],
                    "enumDescriptions": [
                        "",
                        "",
                        "",
                        ""
                    ],
                    "type": "string"
                }
            },
            "type": "object"
        },
        "Output": {
            "id": "Output",
            "properties": {
                "currentDefId": {
                    "description": "The id (Spanner commit timestamp) of the current definition version of\nthis output for the mandate from the request. If this is empty, the\nmandate does not schedule this output (i.e. no instances of this output\nwill be pending for this mandate).",
                    "format": "int64",
                    "type": "string"
                },
                "dependants": {
                    "items": {
                        "format": "int32",
                        "type": "integer"
                    },
                    "type": "array"
                },
                "name": {
                    "type": "string"
                },
                "scheduled": {
                    "description": "DO NOT USE: This field is redundant, if the 'current_def_id' is set, this\noutput is scheduled by the mandate.\n\nIndicates whether the output is scheduled by the mandate for which this\ngraph was retrieved. Outputs that are not scheduled do not have the\ncurrent definition set in the mandate, the instances of these outputs\nwill never be pending for the mandate.",
                    "type": "boolean"
                }
            },
            "type": "object"
        },
        "OutputInfo": {
            "id": "OutputInfo",
            "properties": {
                "name": {
                    "type": "string"
                },
                "schedulingStatus": {
                    "enum": [
                        "UNSPECIFIED",
                        "ACTIVE",
                        "PAUSED"
                    ],
                    "enumDescriptions": [
                        "Not to be used. See go/protodosdonts.",
                        "OutputDef can be used for computing pending instances.",
                        "OutputDef cannot be used for computing pending instances."
                    ],
                    "type": "string"
                }
            },
            "type": "object"
        },
        "OutputInstanceStatusEntry": {
            "id": "OutputInstanceStatusEntry",
            "properties": {
                "failedAttempts": {
                    "description": "The number of attempts we believe failed. Currently this is just\ntotal - successful, however that may change as we track more\ninformation about executions.",
                    "format": "int32",
                    "type": "integer"
                },
                "instance": {
                    "$ref": "DreampipeInternalInstance..Instance",
                    "description": "Full instance details, including all completed versions fulfilling\nthe mandate_id provided in the request."
                },
                "instanceId": {
                    "description": "Canonical ID for this instance.",
                    "type": "string"
                },
                "latestFails": {
                    "description": "Number of successive failed attempts since the last successful attempt or\noverride.",
                    "format": "int32",
                    "type": "integer"
                },
                "pending": {
                    "description": "Is this instance currently pending, i.e. returned in the\nQueryPendingInstances response? See go/dreampipe-pending.",
                    "type": "boolean"
                },
                "running": {
                    "description": "Is there a job currently executing?",
                    "type": "boolean"
                },
                "runningLockValidUntilSecs": {
                    "description": "If set, the timestamp at which the last lock of an executing job\nwill expire. A UI may use this as a time after which it can issue\nanother request to see an updated status.",
                    "format": "int64",
                    "type": "string"
                },
                "successfulAttempts": {
                    "description": "The number of execution attempts which completed successfully.",
                    "format": "int32",
                    "type": "integer"
                },
                "totalAttempts": {
                    "description": "Total recorded attempts to execute this instance, across all versions.",
                    "format": "int32",
                    "type": "integer"
                },
                "unfulfilledBackfills": {
                    "description": "Backfills for which this instance has no fulfilled versions.",
                    "items": {
                        "$ref": "BackfillInfo"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "OutputInstanceStatusResponse": {
            "id": "OutputInstanceStatusResponse",
            "properties": {
                "domain": {
                    "type": "string"
                },
                "instanceStatus": {
                    "items": {
                        "$ref": "OutputInstanceStatusEntry"
                    },
                    "type": "array"
                },
                "instantiation": {
                    "$ref": "DreampipeDefinition..Instantiation",
                    "description": "Instantiation proto of this output as defined in its latest output\ndefinition."
                },
                "name": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "OutputsGraph": {
            "description": "OutputsGraph represents a graph of outputs from a single domain. It contains\na sequence of Outputs sorted by their name. Each output contains a sequence\nof indices pointing to the dependants of the respective output in the outputs\nsequence.",
            "id": "OutputsGraph",
            "properties": {
                "outputs": {
                    "items": {
                        "$ref": "Output"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "OutputsGraphResponse": {
            "id": "OutputsGraphResponse",
            "properties": {
                "outputsGraph": {
                    "$ref": "OutputsGraph"
                }
            },
            "type": "object"
        },
        "PendingInstanceQuery": {
            "id": "PendingInstanceQuery",
            "properties": {
                "domain": {
                    "description": "DEPRECATED. Please use the \"domain:mdb/dreamers\" syntax in expression\ninstead.\n\nThe domain for which you are executing queries.\n\nNote that the domain field also implicitly matches any domains having\nthe same path prefix. In other words, if domain = \"mdb/dreamers\", then\noutputs from domain \"mdb/dreamers/pipeline\" are also matched. This\nbehavior is confusing: do not depend on it. Instead, please migrate to\nusing the expression field.\n\nDEPRECATED.",
                    "type": "string"
                },
                "expression": {
                    "description": "Expression defines the OutputDefs whose instances are considered for this\nquery.\n\nSYNTAX\n\nArbitrary boolean expressions with atoms, e.g. 'tag1', negation '!', binary\noperations '&' and '|' and parentheses '(' and ')' are supported.\nThe precedence of '&' and '|' is undefined, and an attempt to use them at\nthe same level is an error. Negation has higher precedence than either.\n\nYou should have at least 'domain:<domain-name>' or 'owner:<owner>' in the\nexpression.\n\nATOMS\n\nThese atoms are supported:\n\n * 'output:name': the name of the output. This evaluates to true iff the\n    name is equal to OutputDef.name.\n\n * 'tag1' (no prefix). This evaluates to true iff the given tag appears\n   once or more in the list of OutputDef.tag.\n\n * 'domain:mdb/dreamers/pipeline', the domain of the output. This\n   evaluates to true iff the domain is equal to OutputDef.domain.\n   Note that the top-level domain \"mdb/dreamers\" is a valid domain.\n\n * 'owner:mdb/dreamers', the owner of the output. This evaluates to\n   true iff the owner equals to the first two path components of\n   OutputDef.domain.\n\nEXAMPLES\n\n * output:name1 | output:name2\n * tag2\n * (!tag2 & (tag3 | tag4))",
                    "type": "string"
                },
                "inputRequirement": {
                    "description": "Specify any extra information about how the inputs should be handled.",
                    "items": {
                        "$ref": "InputRequirement"
                    },
                    "type": "array"
                },
                "inputSharingOptions": {
                    "$ref": "InputSharingOptions",
                    "description": "The input_sharing_options adds an additional layer of instance filtering\nbased on the input sharing group. It is reserved for private use by SQL\nPipelines; please leave unset in all other contexts. The definition of the\nstrategy may change without advance warning."
                },
                "lockingStrategy": {
                    "$ref": "LockingStrategy",
                    "description": "You may instruct Dreampipe to automatically lock the instances returned\nin the query. If no locking_strategy is specified, QUERY_IGNORE_LOCKS is\nthe default. Otherwise, this has mostly the same effect as calling\nAcquireLock() on the output of this signal, with some differences:\n\n * There are two locking options available that only work in\n   QueryPendingInstances:\n\n   * QUERY_IGNORE_LOCKS ignores locking, so it may return instances that\n     are already locked (this is the default);\n\n   * QUERY_UNLOCKED_ONLY only returns instances that were unlocked at\n     the time of the call, but doesn't actually lock them;\n\n * if you use STEAL_LOCKS, Dreampipe will lock the highest priority\n   outputs, stealing locks as necessary;\n\n * For *all* the other locking options, Dreampipe first determines\n   the eligible set of outputs by looking at unlocked outputs or outputs\n   with expired locks, and only then tries to lock them. Because of this,\n   the locks are by definition guaranteed to succeed (i.e. all outputs\n   returned are also locked).\n\n   (Because of this, the remaining locking options behave essentially the\n   same; in other words, e.g. REQUIRE_ALL_LOCKS behaves the same as\n   REQUIRE_NO_LOCKS.)"
                },
                "mandateExpression": {
                    "description": "Expression defines the mandates (i.e. deployments), which are considered\nfor this query. If you do not use mandates, leave unset.\n\nSYNTAX\n\nArbitrary boolean expressions with atoms, e.g. 'mandate:prod', negation\n'!', binary operations '&' and '|' and parentheses '(' and ')' are\nsupported. The precedence of '&' and '|' is undefined, and an attempt to\nuse them at the same level is an error. Negation has higher precedence than\neither.\n\nIf left non-defined, only default mandate is considered (also known as\ncompatibility mode). In that case, the latest versions of Outputs are\nconsidered for computation and all the OutputInstances are accepted.\n\nEmpty expression (i.e. \"\") is not allowed.\n\nATOMS\n\nThese atoms are supported:\n\n * mandate id, prefixed with 'mandate:'. For example, 'mandate:id'.\n   This evaluates to true iff the id is equal to MandateKey.mandate_id.\n\n * derived_mandate id, prefixed with 'derived_mandate'. This\n   evaluates to true iff the id is equal to any of the mandate\n   ancestors id.\n\nEXAMPLES\n\n * mandate:presubmit | mandate:canary\n * (!derived_mandate:prod & mandate:canary)",
                    "type": "string"
                },
                "maxNumReplies": {
                    "description": "How many output instances we want to return for the query. If there are\nmore than max_num_replies pending instances, we use the scheduling_strategy\nto rank the top replies. If not specified, the default value of 1 is\nassumed.",
                    "format": "int32",
                    "type": "integer"
                },
                "queryTag": {
                    "description": "Describes a list of tags that can group queries together in a launcher pool\nfor resource quota sharing. The desired quota needs to be specified in\nResourcePoolQuota under the \"query_tag\" key_type.\nThis tag is repeated, and the semantics is that we construct a separate\nresource key for each tag, and acquire corresponding resources for all of\nthe keys.\n\nNote: This field has no meaning outside of the launcher pool protocol.\n\nE.g for queries A, B and C, we want to limit the number of parallel\ncomputations to 2, and have at most one A or B computation running at any\nmoment in time. We can group queries A and B under the same tag and limit\nthe no of computations for this tag to 1. This results in limiting the\ncomputations to either of the following combinations: AC, BC and CC.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "retries": {
                    "$ref": "RetryConstraint",
                    "description": "Specify how many times the job should be retried. If not specified,\nDreampipe uses a default policy, which currently allows 3 retries. (Please\ndo not rely on the exact value of the default, as it may change.)"
                },
                "retryThrottling": {
                    "$ref": "RetryThrottling",
                    "description": "Specify how long we should wait prior scheduling next attempt after\nfailed attempt. No throttling is performed by default."
                },
                "schedulingStrategy": {
                    "$ref": "SchedulingStrategy",
                    "description": "The scheduling strategy of this query. If not set, Dreampipe will default\nto a default strategy that schedules frontfills and backfills but no\nrecomputations."
                },
                "selectionScope": {
                    "enumDescriptions": [
                        "",
                        "",
                        "",
                        "",
                        "",
                        ""
                    ],
                    "items": {
                        "enum": [
                            "SELECTION_SCOPE_UNKNOWN",
                            "OUTPUT_DOMAIN",
                            "INSTANCE_VARS",
                            "OUTPUT_NAME",
                            "MPM_SPEC",
                            "MANDATE"
                        ],
                        "type": "string"
                    },
                    "type": "array"
                },
                "skipNonallowed": {
                    "description": "Experimental flag, do not use.\nIf set, the query will never fail due to missing permissions, it will skip\nthose outputs specified by the expression for which the user does not have\nthe permission.",
                    "type": "boolean"
                }
            },
            "type": "object"
        },
        "ProposeBackfillResponse": {
            "id": "ProposeBackfillResponse",
            "properties": {
                "backfillId": {
                    "type": "string"
                },
                "domain": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "QueryActiveLocksResponse": {
            "description": "Response for QueryActiveLocks.",
            "id": "QueryActiveLocksResponse",
            "properties": {
                "locks": {
                    "description": "List of currently active (valid) locks.",
                    "items": {
                        "$ref": "Lock"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "Queue": {
            "id": "Queue",
            "properties": {
                "backfillCountBefore": {
                    "description": "Number of manually backfilled items that precede output instance.",
                    "format": "int32",
                    "type": "integer"
                },
                "backfillCountTotal": {
                    "description": "Total number of manually backfilled items in processed queue.",
                    "format": "int32",
                    "type": "integer"
                },
                "isQueued": {
                    "description": "True is instance is present in the queue.",
                    "type": "boolean"
                },
                "pendingInstanceQueryIndex": {
                    "description": "The index of the PendingInstanceQuery that generated this queue.",
                    "format": "int32",
                    "type": "integer"
                },
                "position": {
                    "description": "Position in the queue if found. Count starts with 1.",
                    "format": "int32",
                    "type": "integer"
                },
                "queueIsTooLarge": {
                    "description": "If true queue is larger than request and not all items are processed,\nin this case instance could be queued but not processed by this query.",
                    "type": "boolean"
                },
                "queueLength": {
                    "description": "Number of processed items in the queue.",
                    "format": "int32",
                    "type": "integer"
                }
            },
            "type": "object"
        },
        "RecentHistoryEntry": {
            "id": "RecentHistoryEntry",
            "properties": {
                "instanceId": {
                    "description": "Canonical ID for this instance.",
                    "type": "string"
                },
                "latest": {
                    "description": "What is the status of the latest job?",
                    "enum": [
                        "UNKNOWN",
                        "SUCCESSFUL",
                        "FAILED",
                        "OVERRIDE",
                        "RUNNING"
                    ],
                    "enumDescriptions": [
                        "",
                        "",
                        "",
                        "",
                        ""
                    ],
                    "type": "string"
                }
            },
            "type": "object"
        },
        "Result": {
            "id": "Result",
            "properties": {
                "instance": {
                    "$ref": "InstanceToComplete"
                },
                "status": {
                    "$ref": "Status"
                }
            },
            "type": "object"
        },
        "RetryConstraint": {
            "description": "The RetryConstraint allows setting scheduling constraints based on the\nnumber of previous retries.\n\nA \"previous\" attempt is any execution that has got a lock_id associated with\nit. Note that the attempt may still be running; you should use the locking\nprotocol to avoid overruns.",
            "id": "RetryConstraint",
            "properties": {
                "maxTotalAttempts": {
                    "description": "If max_total_attempts is set, it only schedules the output instance if the\nnumber of total attempts is <= max_total_attempts. The number of total\nattempts includes the \"current\" attempt, i.e. it's defined as 1 + number\nof previous attempts.",
                    "format": "int32",
                    "type": "integer"
                },
                "minPreviousAttempts": {
                    "description": "If min_previous_attempts is set, it only schedules the output instance\nif the number of attempts is >= min_previous_attempts. The default is 0.\nThis flag is useful e.g. for dedicated retry launchers, which only pick up\nwork that has been tried (and failed) with normal launchers.",
                    "format": "int32",
                    "type": "integer"
                }
            },
            "type": "object"
        },
        "RetryThrottling": {
            "description": "The RetryThrottling allows you to throttle next retry after failed\nattempt.\nThe goal is to avoid fast retry budget depletion due to momentary flakiness\nof infrastructure.",
            "id": "RetryThrottling",
            "properties": {
                "explicit": {
                    "$ref": "Explicit"
                }
            },
            "type": "object"
        },
        "RunInfo": {
            "description": "RunInfo contains information about a particular \"run\", i.e. an invocation\nthat corresponds to a Dreampipe lock.\n\nThis information is intended to be stored by Dreampipe for later debugging.\nIt will be stored for each execution attempt (per lock) as well as for\ncompleted instance versions.\n\nAll fields are optional.",
            "id": "RunInfo",
            "properties": {
                "executorInfo": {
                    "description": "Information about the task(s) executing the actual computation (if\ndifferent from launcher_info).",
                    "items": {
                        "$ref": "TaskInfo"
                    },
                    "type": "array"
                },
                "launcherInfo": {
                    "$ref": "TaskInfo",
                    "description": "Information about the launcher task, i.e. the task talking to Dreampipe and\nscheduling computations."
                },
                "queryToken": {
                    "description": "The dreampipe.query.PendingInstanceQueryResponse.unique_token that\nidentifies the computation attempt from Dreampipe side.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "RunnerJob": {
            "description": "RunnerJob contains information we know about a runner job. It must be fully\nself-contained, in the sense that any launcher can check the current state\nof the job.",
            "id": "RunnerJob",
            "properties": {},
            "type": "object"
        },
        "RunningTasksLookupResponse": {
            "id": "RunningTasksLookupResponse",
            "properties": {
                "domain": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "runInfo": {
                    "items": {
                        "$ref": "RunInfo"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "SawmillInput": {
            "id": "SawmillInput",
            "properties": {
                "logType": {
                    "type": "string"
                },
                "sourceType": {
                    "description": "Matches all Sawmill inputs with these source and log type. An asterix '*'\nacts as a wildcard.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "SchedulingStrategy": {
            "id": "SchedulingStrategy",
            "properties": {
                "composite": {
                    "$ref": "Composite"
                },
                "simple": {
                    "$ref": "Simple"
                }
            },
            "type": "object"
        },
        "SchedulingTimeConstraint": {
            "id": "SchedulingTimeConstraint",
            "properties": {
                "consecutiveInstancesTime": {
                    "$ref": "DreampipeTime..ConsecutiveInstancesTime"
                },
                "currentTime": {
                    "$ref": "DreampipeTime..CurrentTime"
                },
                "endOffset": {
                    "description": "inclusive",
                    "format": "int32",
                    "type": "integer"
                },
                "fixedDateTime": {
                    "$ref": "DreampipeTime..FixedDateTime"
                },
                "lastComputableOrExisting": {
                    "$ref": "DreampipeTime..LastComputableOrExisting"
                },
                "period": {
                    "enum": [
                        "PERIOD_UNKNOWN",
                        "PERIOD_SECOND",
                        "PERIOD_CALENDAR_DAY",
                        "PERIOD_CALENDAR_MONTH"
                    ],
                    "enumDescriptions": [
                        "Not to be used. See go/protodosdonts.",
                        "Second as defined by SI.",
                        "Day defines a calendar day periodicity. Most days are 24 hours long,\nbut around daylight savings times they may be 23 or 25 hours.",
                        "Calendar month periodicity."
                    ],
                    "type": "string"
                },
                "startDateTime": {
                    "$ref": "DreampipeTime..StartDateTime"
                },
                "startOffset": {
                    "description": "Define a time period where this scheduling constraint is active.\nFor a given ref_time, the period is defined as\n\n  ref_time + start_offset * period <= t <= ref_time + end_offset * period.\n\nIf either start_offset or end_offset doesn't exist, the period extends\nindefinitely in the corresponding direction (-inf or +inf).\n\nNote that the ref_time depends on context (e.g. it's likely different each\ntime you schedule the output.)\n\nExample: only schedule the latest instance.\n\n last_computable_or_existing: { }  // only serves as a marker\n start_offset: 0\n end_offset: 0  // just for clarity: this is irrelevant.\n period: PERIOD_CALENDAR_DAY\n\nExample: only schedule everything within the current week (real time)\n\n current_time: { }  // only serves as a marker\n start_offset: -7\n end_offset: 0\n period: PERIOD_CALENDAR_DAY\ninclusive",
                    "format": "int32",
                    "type": "integer"
                }
            },
            "type": "object"
        },
        "SearchBackfillsResponse": {
            "id": "SearchBackfillsResponse",
            "properties": {
                "backfills": {
                    "items": {
                        "$ref": "BackfillSummary"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "SearchQueueStatusResponse": {
            "description": "Launchers' and launcher pools' queues that match SearchQueueStatusResponse.",
            "id": "SearchQueueStatusResponse",
            "properties": {
                "launcherPools": {
                    "items": {
                        "$ref": "LauncherPool"
                    },
                    "type": "array"
                },
                "launcherQueues": {
                    "description": "Launcher and launcher pool queues, sorted by:\n  1) Whether the queue contains the searched instance.\n  2) The position of the instance in the queue or the length of the queue.\n  3) Alphanumeric by borg user and job name.",
                    "items": {
                        "$ref": "LauncherQueue"
                    },
                    "type": "array"
                },
                "pendingInstanceQueries": {
                    "description": "A collection of all PendingInstanceQuery used in the response. The\nindividual queues refer to these entries using an index.",
                    "items": {
                        "$ref": "PendingInstanceQuery"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "Simple": {
            "description": "In the scheduling strategy context, we classify the instances as follows:\n a) COMPUTATION_TYPE_FIRST_COMPUTATION refers to an instance that is being\ncomputed for the first time. Examples:\n     1. the runner has not run successfully for some days, leaving holes\n        in the list of completed instances; or\n     2. instantiation start_date_time is a day in the past when you first\n        add the computation.\n\n b) COMPUTATION_TYPE_RECOMPUTATION refers to a instance that was previously\ncomputed but its inputs have changed and it is now eligible for a\nrecomputation.\n\n c) COMPUTATION_TYPE_MANUAL_BACKFILL refers to a manual, forced backfill\n(see http://g3doc/pipeline/dreampipe/g3doc/manual_backfills), which is\ninitiated by issuing an explicit backfill request. Examples:\n     1. issued a backfill request for forcing a particular computation to\n        be reexecuted e.g. to recover from a code bug; or\n     2. issued a backfill request after a computation definition has\nchanged.\n\nFor more details on the computation types, please refer to\nhttps://g3doc.corp.google.com/pipeline/dreampipe/g3doc/manual_backfills.md?cl=head#decision-table\n\nDEPRECATED: use the Composite strategy instead.",
            "id": "Simple",
            "properties": {
                "backfillOrder": {
                    "enum": [
                        "COMPUTE_OLDEST_FIRST",
                        "COMPUTE_NEWEST_FIRST"
                    ],
                    "enumDescriptions": [
                        "",
                        ""
                    ],
                    "type": "string"
                },
                "backfillWeight": {
                    "format": "double",
                    "type": "number"
                },
                "frontfillOrder": {
                    "enum": [
                        "COMPUTE_OLDEST_FIRST",
                        "COMPUTE_NEWEST_FIRST"
                    ],
                    "enumDescriptions": [
                        "",
                        ""
                    ],
                    "type": "string"
                },
                "frontfillWeight": {
                    "description": "The simple strategy should be sufficient for most teams where the steady\nstate situation is such that all computations have caught up.\n\nThe weight determines the priority: higher-weight jobs are scheduled\nfirst. E.g. if frontfill_weight > backfill_weight > recomputation_weight,\nthen the scheduler will try to schedule frontfills first, followed by\nbackfills and recomputations at the end.\nIn case of multiple instances of the same type (e.g. frontfill), then the\ncomputation order will define the scheduling order.\n\nA weight of 0.0 is pruned for the output. This can be used to remove\nunwanted computations.\n\nNote: In the simple strategy context, a frontfill is a legacy name for a\nfirst computation (COMPUTATION_TYPE_FIRST_COMPUTATION).",
                    "format": "double",
                    "type": "number"
                },
                "recomputationOrder": {
                    "enum": [
                        "COMPUTE_OLDEST_FIRST",
                        "COMPUTE_NEWEST_FIRST"
                    ],
                    "enumDescriptions": [
                        "",
                        ""
                    ],
                    "type": "string"
                },
                "recomputationWeight": {
                    "format": "double",
                    "type": "number"
                },
                "timeConstraint": {
                    "description": "Defines a time period constraint for scheduling. If set, the priority of\ninstances outside the time period is zero.\n\nNote: This is computed per output definition and not across the whole\nquery. It is mostly relevant in case it is set to\nlast_computable_or_existing since the last computable is different\namongst outputs. Therefore, in this case, each output might have a\ndifferent time range for instances to be computed.\n\nNOTE: only 0 or 1 repetitions of time_constraint are supported.\nThis field is repeated for future extensibility.",
                    "items": {
                        "$ref": "SchedulingTimeConstraint"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "Status": {
            "description": "The `Status` type defines a logical error model that is suitable for\ndifferent programming environments, including REST APIs and RPC APIs. It is\nused by [gRPC](https://github.com/grpc). Each `Status` message contains\nthree pieces of data: error code, error message, and error details.\n\nYou can find out more about this error model and how to work with it in the\n[API Design Guide](https://cloud.google.com/apis/design/errors).",
            "id": "Status",
            "properties": {
                "code": {
                    "description": "The status code, which should be an enum value of google.rpc.Code.",
                    "format": "int32",
                    "type": "integer"
                },
                "details": {
                    "description": "A list of messages that carry the error details.  There is a common set of\nmessage types for APIs to use.",
                    "items": {
                        "additionalProperties": {
                            "description": "Properties of the object. Contains field @type with type URL.",
                            "type": "any"
                        },
                        "type": "object"
                    },
                    "type": "array"
                },
                "message": {
                    "description": "A developer-facing error message, which should be in English. Any\nuser-facing error message should be localized and sent in the\ngoogle.rpc.Status.details field, or localized by the client.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "StatusProto": {
            "description": "Wire-format for a Status object",
            "id": "StatusProto",
            "properties": {
                "canonicalCode": {
                    "description": "The canonical error code (see codes.proto) that most closely\ncorresponds to this status. May be missing.",
                    "format": "int32",
                    "type": "integer"
                },
                "code": {
                    "description": "Numeric code drawn from the space specified below. Often, this is the\ncanonical error space, and code is drawn from google3/util/task/codes.proto",
                    "format": "int32",
                    "type": "integer"
                },
                "message": {
                    "description": "Detail message",
                    "type": "string"
                },
                "messageSet": {
                    "$ref": "MessageSet",
                    "description": "message_set associates an arbitrary proto message with the status."
                },
                "payload": {
                    "$ref": "TypedMessage",
                    "description": "DEPRECATED.\n\nThis field was deprecated in 2011 with cl/20297133.  Java support\nfor the field was moved to a proto1 backward compatibility class\nin April 2017 with cl/142615857 and cl/154123203.  There was\nnever support for this field in Go; if set Go will ignore it.\nC++ stopped setting StatusProto::payload in October 2015 with cl/106347055,\nand stopped reading the field in October 2017 with cl/173324114.\n\nIn general, newly written code should use only \"message_set\". If you need\nto maintain backward compatibility with code written before 3/25/2011, do\nthe following:\n\n- During the transition period, either (1) set both \"payload\" and\n  \"message_set\", or (2) write the consumer of StatusProto so that it can\n  forge a MessageSet object from \"payload\" if \"message_set\" is missing.\n  The C++ util::Status implementation does (2).\n\n- Once all the consumers are converted to accept \"message_set\", then\n  remove the use of \"payload\" on the producer side."
                },
                "space": {
                    "description": "The following are usually only present when code != 0\nSpace to which this status belongs",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "TaskInfo": {
            "description": "Information about a task (e.g. borg task) involved in the run.\n\nFor jobs running in corp, consider each invoked binary a separate \"task\".\n\nCould also refer to other kinds of tasks, e.g. an F1 query.\n\nThis is intended for auditing and debugging. All fields are optional and\nshould only be populated if relevant.",
            "id": "TaskInfo",
            "properties": {
                "borgTaskLocation": {
                    "$ref": "BorgTaskLocation"
                },
                "corpTaskLocation": {
                    "$ref": "CorpTaskLocation"
                },
                "description": {
                    "description": "Description of this task, e.g. \"main launcher.\"",
                    "type": "string"
                },
                "futureBorgJobLocation": {
                    "$ref": "FutureBorgJobLocation"
                },
                "persistentDebugLocation": {
                    "description": "Location of persistent debugging information (e.g. logs saved on CNS).\n\nShould exist for at least some time after the run is done.",
                    "items": {
                        "$ref": "DebugLocation"
                    },
                    "type": "array"
                },
                "transientDebugLocation": {
                    "description": "Location of transient debugging information (e.g. \"/statusz\" page URI).\nAssumed to no longer exist after the run is complete.\n\nNote: it's not necessary to fill this in if it can be inferred from\nthe task location (and the task location is populated).",
                    "items": {
                        "$ref": "DebugLocation"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "TypedMessage": {
            "description": "Message that groups a protocol type_id (as defined by MessageSet),\nwith an encoded message of that type.  Its use is similar to\nMessageSet, except it represents a single (type, encoded message)\ninstead of a set.\n\nTo fill for known protocol type:\n  MyProtocolMsg proto;\n  TypedMessage typed_msg;\n  typed_msg.set_type_id(MyProtocolMsg::MESSAGE_TYPE_ID);\n  proto.AppendToCord(typed_msg.mutable_message());\n\nTo fill for unknown protocol type:\n  ProtocolMessage proto;\n  TypedMessage typed_msg;\n  typed_msg.set_type_id(proto.GetMapper()->type_id());\n  proto.AppendToCord(typed_msg.mutable_message());",
            "id": "TypedMessage",
            "properties": {
                "message": {
                    "description": "Message bytes.",
                    "format": "byte",
                    "type": "string"
                },
                "typeId": {
                    "description": "Identifier for the type.",
                    "format": "int32",
                    "type": "integer"
                }
            },
            "type": "object"
        },
        "UnfulfilledBackfillInfo": {
            "id": "UnfulfilledBackfillInfo",
            "properties": {
                "backfillId": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "UserDomainsWithRecentHistoryResponse": {
            "id": "UserDomainsWithRecentHistoryResponse",
            "properties": {
                "ownedDomains": {
                    "description": "List of domains where the user is a member of the domain owner\n(or when the user is the domain owner).",
                    "items": {
                        "$ref": "Domain"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "UserTimestamp": {
            "description": "UserTimestamp is a pair that indicates that a user did something at a\nspecified timestamp.",
            "id": "UserTimestamp",
            "properties": {
                "timestampNs": {
                    "type": "string"
                },
                "user": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "Value": {
            "description": "Next id: 9",
            "id": "Value",
            "properties": {
                "batchComputationDelay": {
                    "description": "Maximum delay between the instantiation timestamp of an output (with\na periodic instantiation policy) and the instantiation timestamp of the\nrespective output instance.\n\nOnly applies to frontfills.",
                    "format": "google-duration",
                    "type": "string"
                },
                "batchComputationLookbackWindow": {
                    "description": "The duration of the lookback_window within which to check output\ninstances. This will look at output instances with an instantiation\ntimestamp between: Now() - batch_computation_lookback_window and Now().\nThe default value is batch_computation_delay + 7 days.\nTODO(b/139672681) This feature is still experimental.",
                    "format": "google-duration",
                    "type": "string"
                },
                "batchComputationNumFailures": {
                    "description": "Number of failed attempts to compute a version to accept before alerting.\nThe attempt count is reset once a computation has been completed\nsuccessfully and only applies to a particular version of that\ncomputation.",
                    "format": "int32",
                    "type": "integer"
                },
                "notificationBuganizerAlias": {
                    "description": "Buganizer component alias to send notifications to. Must specify an email\naddress used to create bugs, such as\nbuganizer-system+${component_id}@google.com",
                    "type": "string"
                },
                "notificationEmail": {
                    "description": "Email addresses to send notifications of monitoring violations to.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "notificationPagerQueue": {
                    "description": "The client escalator queue to send pager alert notifications to.",
                    "type": "string"
                },
                "notificationTemplate": {
                    "description": "Optional override for the notification template to use.\nPlease contact the pulsar-team if you want to set up custom templates.",
                    "type": "string"
                },
                "severity": {
                    "description": "An optional label for the notification severity that maps to where the\nnotifications should be delivered. When using the same severity value in\nmultiple values for the same target, all notification_* fields must be\nset to the same destinations. In other words, a single severity can only\nhave one notification destination configuration. Ideally, it appears only\nonce.\n\nThresholds of different types are allowed to be set within the same Value\nsuch that the severity does not have to be repeated.",
                    "type": "string"
                }
            },
            "type": "object"
        }
    },
    "servicePath": "",
    "title": "Dreampipe API",
    "version": "v1",
    "version_module": true
}